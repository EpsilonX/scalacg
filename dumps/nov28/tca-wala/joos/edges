Ast$$anonfun$3: apply() ===> Ast.$anonfun: apply()
Ast$$anonfun$4: apply() ===> Ast.$anonfun: apply()
Ast$$anonfun$assertAllLinks$1$$anonfun$apply$1: apply(Ljava/lang/Object;) ===> Ast.$anonfun.$anonfun: apply(x$1: Ast.AstNode)
Ast$$anonfun$assertAllLinks$1: apply(Ljava/lang/Object;) ===> Ast.$anonfun: apply(ch: Ast.CompUnit)
Ast$$anonfun$assertLinks$1: apply(Ljava/lang/Object;) ===> Ast.$anonfun: apply(ch: Ast.AstNode)
Ast$$anonfun$assertLinks$2: apply(Ljava/lang/Object;) ===> Ast.$anonfun: apply(ch: Ast.AstNode)
Ast$$anonfun$assertLinks$2: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Ast$$anonfun$ast_CastExpression$1: apply(Ljava/lang/Object;) ===> Ast.$anonfun: apply(x$22: String)
Ast$$anonfun$ast_ClassDeclaration$1: apply(Ljava/lang/Object;) ===> Ast.$anonfun: apply(x$12: Ast.MemberDecl)
Ast$$anonfun$ast_ClassDeclaration$1: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Ast$$anonfun$dfs$1: apply(Ljava/lang/Object;) ===> Ast.$anonfun: apply(ch: Ast.AstNode)
Ast$$anonfun$expandEscapes$1: apply(Ljava/lang/Object;) ===> Ast.$anonfun: apply(c: Char)
Ast$$anonfun$expandEscapes$1: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Ast$$anonfun$main$1: apply(Ljava/lang/Object;) ===> Ast.$anonfun: apply(token: Scanner.Token)
Ast$$anonfun$main$2: apply(Ljava/lang/Object;) ===> Ast.$anonfun: apply(cls: Ast.ClassDecl)
Ast$: <clinit>() ===> Ast: <init>()
Ast$Abstract$: <clinit>() ===> Ast.Abstract: <init>()
Ast$ArraySpec: typ() ===> Ast.ArraySpec: typ()
Ast$ArrayType: spec() ===> Ast.ArrayType: spec()
Ast$AstNode$$anonfun$linkParents$1: apply(Ljava/lang/Object;) ===> Ast.AstNode.$anonfun: apply(c: Ast.AstNode)
Ast$BooleanSpec: typ() ===> Ast.BooleanSpec: typ()
Ast$BooleanType$: <clinit>() ===> Ast.BooleanType: <init>()
Ast$BooleanType$: spec() ===> Ast.BooleanType: spec()
Ast$ByteSpec: typ() ===> Ast.ByteSpec: typ()
Ast$ByteType$: <clinit>() ===> Ast.ByteType: <init>()
Ast$ByteType$: spec() ===> Ast.ByteType: spec()
Ast$CharSpec: typ() ===> Ast.CharSpec: typ()
Ast$CharType$: <clinit>() ===> Ast.CharType: <init>()
Ast$CharType$: spec() ===> Ast.CharType: spec()
Ast$ClassDecl: objFrame$lzycompute() ===> CodeGen: objectFrame(cd: Ast.ClassDecl)
Ast$ConstructorDecl$$anonfun$2: apply(Ljava/lang/Object;) ===> Ast.ConstructorDecl.$anonfun: apply(x$7: Ast.TypeSpec, String)
Ast$ConstructorDecl: frame$lzycompute() ===> CodeGen: constFrame(cd: Ast.ConstructorDecl)
Ast$Final$: <clinit>() ===> Ast.Final: <init>()
Ast$IntSpec: typ() ===> Ast.IntSpec: typ()
Ast$IntType$: <clinit>() ===> Ast.IntType: <init>()
Ast$IntType$: spec() ===> Ast.IntType: spec()
Ast$MethodDecl$$anonfun$1: apply(Ljava/lang/Object;) ===> Ast.MethodDecl.$anonfun: apply(x$4: Ast.TypeSpec, String)
Ast$MethodDecl: frame$lzycompute() ===> CodeGen: methodFrame(md: Ast.MethodDecl)
Ast$Native$: <clinit>() ===> Ast.Native: <init>()
Ast$NullType$: <clinit>() ===> Ast.NullType: <init>()
Ast$NullType$: spec() ===> Ast.NullType: spec()
Ast$Protected$: <clinit>() ===> Ast.Protected: <init>()
Ast$Public$: <clinit>() ===> Ast.Public: <init>()
Ast$RefSpec$$anonfun$typ$1: apply() ===> Ast.RefSpec.$anonfun: apply()
Ast$RefSpec$: <clinit>() ===> Ast.RefSpec: <init>()
Ast$RefSpec: typ() ===> Ast.RefSpec: typ()
Ast$RefType: spec() ===> Ast.RefType: spec()
Ast$ShortSpec: typ() ===> Ast.ShortSpec: typ()
Ast$ShortType$: <clinit>() ===> Ast.ShortType: <init>()
Ast$ShortType$: spec() ===> Ast.ShortType: spec()
Ast$Static$: <clinit>() ===> Ast.Static: <init>()
Ast$TriState$: <clinit>() ===> Ast.TriState: <init>()
Ast$VoidSpec: typ() ===> Ast.VoidSpec: typ()
Ast$VoidType$: <clinit>() ===> Ast.VoidType: <init>()
Ast$VoidType$: spec() ===> Ast.VoidType: spec()
Ast.$anonfun: apply(ch: Ast.AstNode) ===> Ast.ArrayType: equals(x$1: Any)
Ast.$anonfun: apply(ch: Ast.AstNode) ===> Ast.ImportClass: equals(x$1: Any)
Ast.$anonfun: apply(ch: Ast.AstNode) ===> Ast.ImportStar: equals(x$1: Any)
Ast.$anonfun: apply(ch: Ast.AstNode) ===> Ast.Name: equals(x$1: Any)
Ast.$anonfun: apply(ch: Ast.AstNode) ===> Ast.RefType: equals(x$1: Any)
Ast.$anonfun: apply(ch: Ast.AstNode) ===> Names.ConstrSig: equals(x$1: Any)
Ast.$anonfun: apply(ch: Ast.AstNode) ===> Names.MethodSig: equals(x$1: Any)
Ast.$anonfun: apply(ch: Ast.AstNode) ===> Parser.Leaf: equals(x$1: Any)
Ast.$anonfun: apply(ch: Ast.AstNode) ===> Parser.Node: equals(x$1: Any)
Ast.$anonfun: apply(ch: Ast.AstNode) ===> Parser.Production: equals(x$1: Any)
Ast.$anonfun: apply(ch: Ast.AstNode) ===> Parser.Reduce: equals(x$1: Any)
Ast.$anonfun: apply(ch: Ast.AstNode) ===> Parser.Shift: equals(x$1: Any)
Ast.$anonfun: apply(ch: Ast.AstNode) ===> Scanner.Token: equals(x$1: Any)
Ast.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.ArrayType: equals(x$1: Any)
Ast.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.ImportClass: equals(x$1: Any)
Ast.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.ImportStar: equals(x$1: Any)
Ast.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.Name: equals(x$1: Any)
Ast.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.RefType: equals(x$1: Any)
Ast.$anonfun: apply(cls: Ast.ClassDecl) ===> Names.ConstrSig: equals(x$1: Any)
Ast.$anonfun: apply(cls: Ast.ClassDecl) ===> Names.MethodSig: equals(x$1: Any)
Ast.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Leaf: equals(x$1: Any)
Ast.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Node: equals(x$1: Any)
Ast.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Production: equals(x$1: Any)
Ast.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Reduce: equals(x$1: Any)
Ast.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Shift: equals(x$1: Any)
Ast.$anonfun: apply(cls: Ast.ClassDecl) ===> Scanner.Token: equals(x$1: Any)
Ast.Abstract: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.ByteType: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.CharType: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.IntType: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.Modifier: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.Name: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.NullType: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.RefType: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.ShortType: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.VoidType: toString()
Ast.Abstract: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Ast.Abstract: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Ast.Abstract: productElement(x$1: Int) ===> Names.Env: toString()
Ast.Abstract: productElement(x$1: Int) ===> Names.MethodSig: toString()
Ast.Abstract: productElement(x$1: Int) ===> Parser.Leaf: toString()
Ast.Abstract: productElement(x$1: Int) ===> Parser.Node: toString()
Ast.Abstract: productElement(x$1: Int) ===> Parser.Production: toString()
Ast.Abstract: productElement(x$1: Int) ===> Parser.Reduce: toString()
Ast.Abstract: productElement(x$1: Int) ===> Parser.Shift: toString()
Ast.Abstract: productElement(x$1: Int) ===> Scanner.Token: toString()
Ast.Abstract: productElement(x$1: Int) ===> Util$Memoize: toString()
Ast.ArraySpec: typ() ===> Ast$ArraySpec: typ()
Ast.ArraySpec: typ() ===> Ast$BooleanSpec: typ()
Ast.ArraySpec: typ() ===> Ast$ByteSpec: typ()
Ast.ArraySpec: typ() ===> Ast$CharSpec: typ()
Ast.ArraySpec: typ() ===> Ast$IntSpec: typ()
Ast.ArraySpec: typ() ===> Ast$RefSpec: typ()
Ast.ArraySpec: typ() ===> Ast$ShortSpec: typ()
Ast.ArraySpec: typ() ===> Ast$VoidSpec: typ()
Ast.ArrayType: equals(x$1: Any) ===> Ast.ArrayType: equals(x$1: Any)
Ast.ArrayType: equals(x$1: Any) ===> Ast.ImportClass: equals(x$1: Any)
Ast.ArrayType: equals(x$1: Any) ===> Ast.ImportStar: equals(x$1: Any)
Ast.ArrayType: equals(x$1: Any) ===> Ast.Name: equals(x$1: Any)
Ast.ArrayType: equals(x$1: Any) ===> Ast.RefType: equals(x$1: Any)
Ast.ArrayType: equals(x$1: Any) ===> Names.ConstrSig: equals(x$1: Any)
Ast.ArrayType: equals(x$1: Any) ===> Names.MethodSig: equals(x$1: Any)
Ast.ArrayType: equals(x$1: Any) ===> Parser.Leaf: equals(x$1: Any)
Ast.ArrayType: equals(x$1: Any) ===> Parser.Node: equals(x$1: Any)
Ast.ArrayType: equals(x$1: Any) ===> Parser.Production: equals(x$1: Any)
Ast.ArrayType: equals(x$1: Any) ===> Parser.Reduce: equals(x$1: Any)
Ast.ArrayType: equals(x$1: Any) ===> Parser.Shift: equals(x$1: Any)
Ast.ArrayType: equals(x$1: Any) ===> Scanner.Token: equals(x$1: Any)
Ast.ArrayType: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.ByteType: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.CharType: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.IntType: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.Modifier: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.Name: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.NullType: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.RefType: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.ShortType: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.VoidType: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Names.Env: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Names.MethodSig: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Parser.Leaf: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Parser.Node: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Parser.Production: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Parser.Reduce: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Parser.Shift: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Scanner.Token: toString()
Ast.ArrayType: productElement(x$1: Int) ===> Util$Memoize: toString()
Ast.ArrayType: spec() ===> Ast$ArrayType: spec()
Ast.ArrayType: spec() ===> Ast$BooleanType$: spec()
Ast.ArrayType: spec() ===> Ast$ByteType$: spec()
Ast.ArrayType: spec() ===> Ast$CharType$: spec()
Ast.ArrayType: spec() ===> Ast$IntType$: spec()
Ast.ArrayType: spec() ===> Ast$NullType$: spec()
Ast.ArrayType: spec() ===> Ast$RefType: spec()
Ast.ArrayType: spec() ===> Ast$ShortType$: spec()
Ast.ArrayType: spec() ===> Ast$VoidType$: spec()
Ast.AstNode: $init$() ===> Ast.AstNode: env_=(x$1: Names.Env)
Ast.AstNode: $init$() ===> Ast.AstNode: parent_=(x$1: Ast.AstNode)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Ast$$anonfun$assertAllLinks$1$$anonfun$apply$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Ast$$anonfun$assertAllLinks$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Ast$$anonfun$assertLinks$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Ast$$anonfun$assertLinks$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Ast$$anonfun$ast_CastExpression$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Ast$$anonfun$ast_ClassDeclaration$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Ast$$anonfun$dfs$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Ast$$anonfun$expandEscapes$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Ast$$anonfun$main$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Ast$$anonfun$main$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Ast$AstNode$$anonfun$linkParents$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Ast$ConstructorDecl$$anonfun$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Ast$MethodDecl$$anonfun$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anon$2$$anonfun$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anon$3$$anonfun$8: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anon$3$$anonfun$code$4: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anon$4$$anonfun$code$5: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$7: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$9$$anonfun$apply$21: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$9$$anonfun$apply$22: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$9: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$arrayFrame$lzycompute$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$classFrame$lzycompute$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$3: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$4: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$5: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$15$$anonfun$apply$16: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$15: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$17: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$18: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$19$$anonfun$apply$20: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$19: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$6: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$13: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$10: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$11$$anonfun$apply$12: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$11: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$3: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$4: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$3: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$codeGen$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$constFrame$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$constFrame$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$constrSig$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$main$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$mainClass$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$makeFrame$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$makeFrame$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$methodFrame$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$methodFrame$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$methodSig$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$objectFrame$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$objectFrame$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$$anonfun$objectFrame$3: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$2$$anonfun$apply$3: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$interfaceInvoke$2$$anonfun$3: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$4: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$5: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$6: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$interfaceInvoke$2$$anonfun$code$3: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$subtypeTests$2$$anonfun$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$subtypeTests$2$$anonfun$code$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> CodeGen$subtypeTests$2$$anonfun$code$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> MakeAst$$anonfun$main$1$$anonfun$apply$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> MakeAst$$anonfun$main$1$$anonfun$apply$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> MakeAst$$anonfun$main$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$10: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$12$$anonfun$apply$76: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$12$$anonfun$apply$77: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$12: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$8: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$9: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$32: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$34: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$36: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$37: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$38: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addAbstractObjectMethods$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$39: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$40: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$11: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$43: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$44: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$45: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$46: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addAbstractObjectMethods$1$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addClasses$1$1$$anonfun$apply$5: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$addClasses$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$canonicalNames$1$1$$anonfun$apply$4: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$canonicalNames$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20$$anonfun$apply$21$$anonfun$apply$22: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20$$anonfun$apply$21: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkDemandPackageIsClass$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkHierarchyCycles$1$1$$anonfun$apply$31: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkHierarchyCycles$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$28: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$29$$anonfun$apply$30: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$29: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkInterfaceFields$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17$$anonfun$apply$18$$anonfun$apply$19: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17$$anonfun$apply$18: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkNonExistingPackage$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkPackageClashWithType$1$1$$anonfun$apply$25: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkPackageClashWithType$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkPrefixesOfReferences$1$1$$anonfun$apply$26: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkPrefixesOfReferences$1$1$$anonfun$apply$27: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkPrefixesOfReferences$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkSingleTypeImports$1$1$$anonfun$apply$15$$anonfun$apply$16: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkSingleTypeImports$1$1$$anonfun$apply$15: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$checkSingleTypeImports$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$demandImports$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$demImp$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$demImp$1$2$$anonfun$apply$23: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$demImp$1$2$$anonfun$apply$24: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$demImp$1$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$enclosingBlock$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$enclosingClass$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$environments$1$$anonfun$apply$14: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$environments$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$63: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$64: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$66: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$67: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$68: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$69: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$70: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$71: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$73: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$74: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$75: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$hierarchy$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$interfaces$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$isSubtype$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$main$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$makeEnvs$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$10: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$11: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$12$$anonfun$apply$13: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$12: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$6: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$7: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$8$$anonfun$apply$9: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$8: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$Names$$addMembers$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$Names$$dfs$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$resolveTypes$1$1$$anonfun$7: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$resolveTypes$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$singleImports$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$$anonfun$typeLinking$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$ConstrSig$$anonfun$apply$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$Env$$anonfun$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$Env$$anonfun$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$Env$$anonfun$4$$anonfun$apply$3: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$Env$$anonfun$5: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$Env$$anonfun$lookupClass$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$Env$$anonfun$Names$Env$$tryName$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$Env$$anonfun$resolveClass$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$FieldCheck$$anonfun$declare$3: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$FieldCheck$$anonfun$declare$4: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$FieldCheck$$anonfun$inherit$2$$anonfun$apply$61: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$FieldCheck$$anonfun$inherit$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$allabs$1$$anonfun$apply$47: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$allabs$1$$anonfun$apply$48: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$allabs$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$declare$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$declare$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$49: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$50: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$51: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$inherit$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$nodecl$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$replace$1$$anonfun$apply$53: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$replace$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$56: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$57: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$58: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$59: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$60: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$replace$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$replaceM$1$$anonfun$apply$52: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodCheck$$anonfun$replaceM$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Names$MethodSig$$anonfun$apply$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Parser$$anon$1$$anonfun$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Parser$$anon$1$$anonfun$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Parser$$anonfun$main$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Parser$$anonfun$parse$1$$anonfun$go$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Parser$$anonfun$parse$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Parser$$anonfun$Parser$$nlines$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Parser$Node$$anonfun$toString$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Scanner$$anonfun$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Scanner$$anonfun$main$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Scanner$$anonfun$maximalmunch$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Scanner$$anonfun$maximalmunch$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> StaticAnal$$anonfun$1$$anonfun$apply$3: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> StaticAnal$$anonfun$1$$anonfun$apply$4: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> StaticAnal$$anonfun$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> StaticAnal$$anonfun$definiteAssignment$1$$anonfun$apply$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> StaticAnal$$anonfun$definiteAssignment$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> StaticAnal$$anonfun$main$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> StaticAnal$$anonfun$reachability$1$$anonfun$apply$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> StaticAnal$$anonfun$reachability$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$3: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$4: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$5: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$6$$anonfun$apply$24: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$6$$anonfun$apply$25: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$6: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$checkAccess$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20$$anonfun$apply$21: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20$$anonfun$apply$22: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$checkConstructorNames$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$15: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$17: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$18: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$19: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$checkForwardReferences$1$1$$anonfun$apply$23: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$checkForwardReferences$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$checkTypes$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disambiguation$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disField$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disField$1$2$$anonfun$apply$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disField$1$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disField$1$3$$anonfun$apply$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disField$1$3: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disField$1$4$$anonfun$apply$3$$anonfun$apply$4: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disField$1$4$$anonfun$apply$3: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disField$1$4: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disField$1$5: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disField$1$6: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disInvoke$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$10: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$11: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$12: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$13: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$14: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$9: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$disLval$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$formalConf$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$main$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$Types$$disMethod$1$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$Types$$disMethod$1$2$$anonfun$apply$5: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$Types$$disMethod$1$2: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$Types$$disMethod$1$3$$anonfun$apply$6: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$Types$$disMethod$1$3: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$Types$$disMethod$1$4$$anonfun$apply$7$$anonfun$apply$8: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$Types$$disMethod$1$4$$anonfun$apply$7: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$Types$$disMethod$1$4: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$Types$$disMethod$1$5: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Types$$anonfun$Types$$disMethod$1$6: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Util$$anonfun$closure$1: apply(Ljava/lang/Object;)
Ast.AstNode: ancestor(pred: Ast.AstNode => Boolean) ===> Util.Memoize: apply(k: Key)
Ast.AstNode: linkParents() ===> Ast.AstNode: linkParents()
Ast.BinExpr: toString() ===> Ast.ArrayType: toString()
Ast.BinExpr: toString() ===> Ast.BooleanType: toString()
Ast.BinExpr: toString() ===> Ast.ByteType: toString()
Ast.BinExpr: toString() ===> Ast.CharType: toString()
Ast.BinExpr: toString() ===> Ast.ClassDecl: toString()
Ast.BinExpr: toString() ===> Ast.ExprStmt: toString()
Ast.BinExpr: toString() ===> Ast.FieldDecl: toString()
Ast.BinExpr: toString() ===> Ast.ForStmt: toString()
Ast.BinExpr: toString() ===> Ast.IfStmt: toString()
Ast.BinExpr: toString() ===> Ast.ImportClass: toString()
Ast.BinExpr: toString() ===> Ast.ImportStar: toString()
Ast.BinExpr: toString() ===> Ast.IntType: toString()
Ast.BinExpr: toString() ===> Ast.MethodDecl: toString()
Ast.BinExpr: toString() ===> Ast.Modifier: toString()
Ast.BinExpr: toString() ===> Ast.Name: toString()
Ast.BinExpr: toString() ===> Ast.NullType: toString()
Ast.BinExpr: toString() ===> Ast.RefSpec: toString()
Ast.BinExpr: toString() ===> Ast.RefType: toString()
Ast.BinExpr: toString() ===> Ast.ReturnStmt: toString()
Ast.BinExpr: toString() ===> Ast.ShortType: toString()
Ast.BinExpr: toString() ===> Ast.VarDeclStmt: toString()
Ast.BinExpr: toString() ===> Ast.VoidType: toString()
Ast.BinExpr: toString() ===> Ast.WhileStmt: toString()
Ast.BinExpr: toString() ===> Names.ConstrSig: toString()
Ast.BinExpr: toString() ===> Names.Env: toString()
Ast.BinExpr: toString() ===> Names.MethodSig: toString()
Ast.BinExpr: toString() ===> Parser.Leaf: toString()
Ast.BinExpr: toString() ===> Parser.Node: toString()
Ast.BinExpr: toString() ===> Parser.Production: toString()
Ast.BinExpr: toString() ===> Parser.Reduce: toString()
Ast.BinExpr: toString() ===> Parser.Shift: toString()
Ast.BinExpr: toString() ===> Scanner.Token: toString()
Ast.BinExpr: toString() ===> Util$Memoize: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.ByteType: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.CharType: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.IntType: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.Modifier: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.Name: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.NullType: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.RefType: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.ShortType: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.VoidType: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Names.Env: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Names.MethodSig: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Parser.Leaf: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Parser.Node: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Parser.Production: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Parser.Reduce: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Parser.Shift: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Scanner.Token: toString()
Ast.BooleanType: productElement(x$1: Int) ===> Util$Memoize: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.ByteType: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.CharType: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.IntType: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.Modifier: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.Name: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.NullType: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.RefType: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.ShortType: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.VoidType: toString()
Ast.ByteType: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Ast.ByteType: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Ast.ByteType: productElement(x$1: Int) ===> Names.Env: toString()
Ast.ByteType: productElement(x$1: Int) ===> Names.MethodSig: toString()
Ast.ByteType: productElement(x$1: Int) ===> Parser.Leaf: toString()
Ast.ByteType: productElement(x$1: Int) ===> Parser.Node: toString()
Ast.ByteType: productElement(x$1: Int) ===> Parser.Production: toString()
Ast.ByteType: productElement(x$1: Int) ===> Parser.Reduce: toString()
Ast.ByteType: productElement(x$1: Int) ===> Parser.Shift: toString()
Ast.ByteType: productElement(x$1: Int) ===> Scanner.Token: toString()
Ast.ByteType: productElement(x$1: Int) ===> Util$Memoize: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.ByteType: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.CharType: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.IntType: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.Modifier: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.Name: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.NullType: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.RefType: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.ShortType: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.VoidType: toString()
Ast.CharType: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Ast.CharType: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Ast.CharType: productElement(x$1: Int) ===> Names.Env: toString()
Ast.CharType: productElement(x$1: Int) ===> Names.MethodSig: toString()
Ast.CharType: productElement(x$1: Int) ===> Parser.Leaf: toString()
Ast.CharType: productElement(x$1: Int) ===> Parser.Node: toString()
Ast.CharType: productElement(x$1: Int) ===> Parser.Production: toString()
Ast.CharType: productElement(x$1: Int) ===> Parser.Reduce: toString()
Ast.CharType: productElement(x$1: Int) ===> Parser.Shift: toString()
Ast.CharType: productElement(x$1: Int) ===> Scanner.Token: toString()
Ast.CharType: productElement(x$1: Int) ===> Util$Memoize: toString()
Ast.ClassDecl: objFrame() ===> Ast$ClassDecl: objFrame$lzycompute()
Ast.ConstructorDecl: frame() ===> Ast$ConstructorDecl: frame$lzycompute()
Ast.FieldExpr: toString() ===> Ast.ArrayType: toString()
Ast.FieldExpr: toString() ===> Ast.BooleanType: toString()
Ast.FieldExpr: toString() ===> Ast.ByteType: toString()
Ast.FieldExpr: toString() ===> Ast.CharType: toString()
Ast.FieldExpr: toString() ===> Ast.ClassDecl: toString()
Ast.FieldExpr: toString() ===> Ast.ExprStmt: toString()
Ast.FieldExpr: toString() ===> Ast.FieldDecl: toString()
Ast.FieldExpr: toString() ===> Ast.ForStmt: toString()
Ast.FieldExpr: toString() ===> Ast.IfStmt: toString()
Ast.FieldExpr: toString() ===> Ast.ImportClass: toString()
Ast.FieldExpr: toString() ===> Ast.ImportStar: toString()
Ast.FieldExpr: toString() ===> Ast.IntType: toString()
Ast.FieldExpr: toString() ===> Ast.MethodDecl: toString()
Ast.FieldExpr: toString() ===> Ast.Modifier: toString()
Ast.FieldExpr: toString() ===> Ast.Name: toString()
Ast.FieldExpr: toString() ===> Ast.NullType: toString()
Ast.FieldExpr: toString() ===> Ast.RefSpec: toString()
Ast.FieldExpr: toString() ===> Ast.RefType: toString()
Ast.FieldExpr: toString() ===> Ast.ReturnStmt: toString()
Ast.FieldExpr: toString() ===> Ast.ShortType: toString()
Ast.FieldExpr: toString() ===> Ast.VarDeclStmt: toString()
Ast.FieldExpr: toString() ===> Ast.VoidType: toString()
Ast.FieldExpr: toString() ===> Ast.WhileStmt: toString()
Ast.FieldExpr: toString() ===> Names.ConstrSig: toString()
Ast.FieldExpr: toString() ===> Names.Env: toString()
Ast.FieldExpr: toString() ===> Names.MethodSig: toString()
Ast.FieldExpr: toString() ===> Parser.Leaf: toString()
Ast.FieldExpr: toString() ===> Parser.Node: toString()
Ast.FieldExpr: toString() ===> Parser.Production: toString()
Ast.FieldExpr: toString() ===> Parser.Reduce: toString()
Ast.FieldExpr: toString() ===> Parser.Shift: toString()
Ast.FieldExpr: toString() ===> Scanner.Token: toString()
Ast.FieldExpr: toString() ===> Util$Memoize: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.ByteType: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.CharType: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.IntType: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.Modifier: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.Name: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.NullType: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.RefType: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.ShortType: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.VoidType: toString()
Ast.Final: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Ast.Final: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Ast.Final: productElement(x$1: Int) ===> Names.Env: toString()
Ast.Final: productElement(x$1: Int) ===> Names.MethodSig: toString()
Ast.Final: productElement(x$1: Int) ===> Parser.Leaf: toString()
Ast.Final: productElement(x$1: Int) ===> Parser.Node: toString()
Ast.Final: productElement(x$1: Int) ===> Parser.Production: toString()
Ast.Final: productElement(x$1: Int) ===> Parser.Reduce: toString()
Ast.Final: productElement(x$1: Int) ===> Parser.Shift: toString()
Ast.Final: productElement(x$1: Int) ===> Scanner.Token: toString()
Ast.Final: productElement(x$1: Int) ===> Util$Memoize: toString()
Ast.ImportClass: equals(x$1: Any) ===> Ast.ArrayType: equals(x$1: Any)
Ast.ImportClass: equals(x$1: Any) ===> Ast.ImportClass: equals(x$1: Any)
Ast.ImportClass: equals(x$1: Any) ===> Ast.ImportStar: equals(x$1: Any)
Ast.ImportClass: equals(x$1: Any) ===> Ast.Name: equals(x$1: Any)
Ast.ImportClass: equals(x$1: Any) ===> Ast.RefType: equals(x$1: Any)
Ast.ImportClass: equals(x$1: Any) ===> Names.ConstrSig: equals(x$1: Any)
Ast.ImportClass: equals(x$1: Any) ===> Names.MethodSig: equals(x$1: Any)
Ast.ImportClass: equals(x$1: Any) ===> Parser.Leaf: equals(x$1: Any)
Ast.ImportClass: equals(x$1: Any) ===> Parser.Node: equals(x$1: Any)
Ast.ImportClass: equals(x$1: Any) ===> Parser.Production: equals(x$1: Any)
Ast.ImportClass: equals(x$1: Any) ===> Parser.Reduce: equals(x$1: Any)
Ast.ImportClass: equals(x$1: Any) ===> Parser.Shift: equals(x$1: Any)
Ast.ImportClass: equals(x$1: Any) ===> Scanner.Token: equals(x$1: Any)
Ast.ImportClass: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.ByteType: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.CharType: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.IntType: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.Modifier: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.Name: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.NullType: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.RefType: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.ShortType: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.VoidType: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Names.Env: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Names.MethodSig: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Parser.Leaf: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Parser.Node: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Parser.Production: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Parser.Reduce: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Parser.Shift: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Scanner.Token: toString()
Ast.ImportClass: productElement(x$1: Int) ===> Util$Memoize: toString()
Ast.ImportStar: equals(x$1: Any) ===> Ast.ArrayType: equals(x$1: Any)
Ast.ImportStar: equals(x$1: Any) ===> Ast.ImportClass: equals(x$1: Any)
Ast.ImportStar: equals(x$1: Any) ===> Ast.ImportStar: equals(x$1: Any)
Ast.ImportStar: equals(x$1: Any) ===> Ast.Name: equals(x$1: Any)
Ast.ImportStar: equals(x$1: Any) ===> Ast.RefType: equals(x$1: Any)
Ast.ImportStar: equals(x$1: Any) ===> Names.ConstrSig: equals(x$1: Any)
Ast.ImportStar: equals(x$1: Any) ===> Names.MethodSig: equals(x$1: Any)
Ast.ImportStar: equals(x$1: Any) ===> Parser.Leaf: equals(x$1: Any)
Ast.ImportStar: equals(x$1: Any) ===> Parser.Node: equals(x$1: Any)
Ast.ImportStar: equals(x$1: Any) ===> Parser.Production: equals(x$1: Any)
Ast.ImportStar: equals(x$1: Any) ===> Parser.Reduce: equals(x$1: Any)
Ast.ImportStar: equals(x$1: Any) ===> Parser.Shift: equals(x$1: Any)
Ast.ImportStar: equals(x$1: Any) ===> Scanner.Token: equals(x$1: Any)
Ast.ImportStar: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.ByteType: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.CharType: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.IntType: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.Modifier: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.Name: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.NullType: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.RefType: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.ShortType: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.VoidType: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Names.Env: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Names.MethodSig: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Parser.Leaf: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Parser.Node: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Parser.Production: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Parser.Reduce: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Parser.Shift: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Scanner.Token: toString()
Ast.ImportStar: productElement(x$1: Int) ===> Util$Memoize: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.ByteType: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.CharType: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.IntType: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.Modifier: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.Name: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.NullType: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.RefType: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.ShortType: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.VoidType: toString()
Ast.IntType: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Ast.IntType: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Ast.IntType: productElement(x$1: Int) ===> Names.Env: toString()
Ast.IntType: productElement(x$1: Int) ===> Names.MethodSig: toString()
Ast.IntType: productElement(x$1: Int) ===> Parser.Leaf: toString()
Ast.IntType: productElement(x$1: Int) ===> Parser.Node: toString()
Ast.IntType: productElement(x$1: Int) ===> Parser.Production: toString()
Ast.IntType: productElement(x$1: Int) ===> Parser.Reduce: toString()
Ast.IntType: productElement(x$1: Int) ===> Parser.Shift: toString()
Ast.IntType: productElement(x$1: Int) ===> Scanner.Token: toString()
Ast.IntType: productElement(x$1: Int) ===> Util$Memoize: toString()
Ast.MethodDecl: frame() ===> Ast$MethodDecl: frame$lzycompute()
Ast.Name: equals(x$1: Any) ===> Ast.ArrayType: equals(x$1: Any)
Ast.Name: equals(x$1: Any) ===> Ast.ImportClass: equals(x$1: Any)
Ast.Name: equals(x$1: Any) ===> Ast.ImportStar: equals(x$1: Any)
Ast.Name: equals(x$1: Any) ===> Ast.Name: equals(x$1: Any)
Ast.Name: equals(x$1: Any) ===> Ast.RefType: equals(x$1: Any)
Ast.Name: equals(x$1: Any) ===> Names.ConstrSig: equals(x$1: Any)
Ast.Name: equals(x$1: Any) ===> Names.MethodSig: equals(x$1: Any)
Ast.Name: equals(x$1: Any) ===> Parser.Leaf: equals(x$1: Any)
Ast.Name: equals(x$1: Any) ===> Parser.Node: equals(x$1: Any)
Ast.Name: equals(x$1: Any) ===> Parser.Production: equals(x$1: Any)
Ast.Name: equals(x$1: Any) ===> Parser.Reduce: equals(x$1: Any)
Ast.Name: equals(x$1: Any) ===> Parser.Shift: equals(x$1: Any)
Ast.Name: equals(x$1: Any) ===> Scanner.Token: equals(x$1: Any)
Ast.Name: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.ByteType: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.CharType: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.IntType: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.Modifier: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.Name: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.NullType: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.RefType: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.ShortType: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.VoidType: toString()
Ast.Name: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Ast.Name: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Ast.Name: productElement(x$1: Int) ===> Names.Env: toString()
Ast.Name: productElement(x$1: Int) ===> Names.MethodSig: toString()
Ast.Name: productElement(x$1: Int) ===> Parser.Leaf: toString()
Ast.Name: productElement(x$1: Int) ===> Parser.Node: toString()
Ast.Name: productElement(x$1: Int) ===> Parser.Production: toString()
Ast.Name: productElement(x$1: Int) ===> Parser.Reduce: toString()
Ast.Name: productElement(x$1: Int) ===> Parser.Shift: toString()
Ast.Name: productElement(x$1: Int) ===> Scanner.Token: toString()
Ast.Name: productElement(x$1: Int) ===> Util$Memoize: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.ByteType: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.CharType: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.IntType: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.Modifier: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.Name: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.NullType: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.RefType: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.ShortType: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.VoidType: toString()
Ast.Native: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Ast.Native: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Ast.Native: productElement(x$1: Int) ===> Names.Env: toString()
Ast.Native: productElement(x$1: Int) ===> Names.MethodSig: toString()
Ast.Native: productElement(x$1: Int) ===> Parser.Leaf: toString()
Ast.Native: productElement(x$1: Int) ===> Parser.Node: toString()
Ast.Native: productElement(x$1: Int) ===> Parser.Production: toString()
Ast.Native: productElement(x$1: Int) ===> Parser.Reduce: toString()
Ast.Native: productElement(x$1: Int) ===> Parser.Shift: toString()
Ast.Native: productElement(x$1: Int) ===> Scanner.Token: toString()
Ast.Native: productElement(x$1: Int) ===> Util$Memoize: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.ByteType: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.CharType: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.IntType: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.Modifier: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.Name: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.NullType: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.RefType: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.ShortType: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.VoidType: toString()
Ast.NullType: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Ast.NullType: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Ast.NullType: productElement(x$1: Int) ===> Names.Env: toString()
Ast.NullType: productElement(x$1: Int) ===> Names.MethodSig: toString()
Ast.NullType: productElement(x$1: Int) ===> Parser.Leaf: toString()
Ast.NullType: productElement(x$1: Int) ===> Parser.Node: toString()
Ast.NullType: productElement(x$1: Int) ===> Parser.Production: toString()
Ast.NullType: productElement(x$1: Int) ===> Parser.Reduce: toString()
Ast.NullType: productElement(x$1: Int) ===> Parser.Shift: toString()
Ast.NullType: productElement(x$1: Int) ===> Scanner.Token: toString()
Ast.NullType: productElement(x$1: Int) ===> Util$Memoize: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.ByteType: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.CharType: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.IntType: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.Modifier: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.Name: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.NullType: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.RefType: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.ShortType: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.VoidType: toString()
Ast.Protected: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Ast.Protected: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Ast.Protected: productElement(x$1: Int) ===> Names.Env: toString()
Ast.Protected: productElement(x$1: Int) ===> Names.MethodSig: toString()
Ast.Protected: productElement(x$1: Int) ===> Parser.Leaf: toString()
Ast.Protected: productElement(x$1: Int) ===> Parser.Node: toString()
Ast.Protected: productElement(x$1: Int) ===> Parser.Production: toString()
Ast.Protected: productElement(x$1: Int) ===> Parser.Reduce: toString()
Ast.Protected: productElement(x$1: Int) ===> Parser.Shift: toString()
Ast.Protected: productElement(x$1: Int) ===> Scanner.Token: toString()
Ast.Protected: productElement(x$1: Int) ===> Util$Memoize: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.ByteType: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.CharType: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.IntType: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.Modifier: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.Name: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.NullType: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.RefType: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.ShortType: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.VoidType: toString()
Ast.Public: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Ast.Public: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Ast.Public: productElement(x$1: Int) ===> Names.Env: toString()
Ast.Public: productElement(x$1: Int) ===> Names.MethodSig: toString()
Ast.Public: productElement(x$1: Int) ===> Parser.Leaf: toString()
Ast.Public: productElement(x$1: Int) ===> Parser.Node: toString()
Ast.Public: productElement(x$1: Int) ===> Parser.Production: toString()
Ast.Public: productElement(x$1: Int) ===> Parser.Reduce: toString()
Ast.Public: productElement(x$1: Int) ===> Parser.Shift: toString()
Ast.Public: productElement(x$1: Int) ===> Scanner.Token: toString()
Ast.Public: productElement(x$1: Int) ===> Util$Memoize: toString()
Ast.RefType: equals(x$1: Any) ===> Ast.ArrayType: equals(x$1: Any)
Ast.RefType: equals(x$1: Any) ===> Ast.ImportClass: equals(x$1: Any)
Ast.RefType: equals(x$1: Any) ===> Ast.ImportStar: equals(x$1: Any)
Ast.RefType: equals(x$1: Any) ===> Ast.Name: equals(x$1: Any)
Ast.RefType: equals(x$1: Any) ===> Ast.RefType: equals(x$1: Any)
Ast.RefType: equals(x$1: Any) ===> Names.ConstrSig: equals(x$1: Any)
Ast.RefType: equals(x$1: Any) ===> Names.MethodSig: equals(x$1: Any)
Ast.RefType: equals(x$1: Any) ===> Parser.Leaf: equals(x$1: Any)
Ast.RefType: equals(x$1: Any) ===> Parser.Node: equals(x$1: Any)
Ast.RefType: equals(x$1: Any) ===> Parser.Production: equals(x$1: Any)
Ast.RefType: equals(x$1: Any) ===> Parser.Reduce: equals(x$1: Any)
Ast.RefType: equals(x$1: Any) ===> Parser.Shift: equals(x$1: Any)
Ast.RefType: equals(x$1: Any) ===> Scanner.Token: equals(x$1: Any)
Ast.RefType: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.ByteType: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.CharType: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.IntType: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.Modifier: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.Name: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.NullType: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.RefType: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.ShortType: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.VoidType: toString()
Ast.RefType: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Ast.RefType: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Ast.RefType: productElement(x$1: Int) ===> Names.Env: toString()
Ast.RefType: productElement(x$1: Int) ===> Names.MethodSig: toString()
Ast.RefType: productElement(x$1: Int) ===> Parser.Leaf: toString()
Ast.RefType: productElement(x$1: Int) ===> Parser.Node: toString()
Ast.RefType: productElement(x$1: Int) ===> Parser.Production: toString()
Ast.RefType: productElement(x$1: Int) ===> Parser.Reduce: toString()
Ast.RefType: productElement(x$1: Int) ===> Parser.Shift: toString()
Ast.RefType: productElement(x$1: Int) ===> Scanner.Token: toString()
Ast.RefType: productElement(x$1: Int) ===> Util$Memoize: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.ByteType: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.CharType: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.IntType: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.Modifier: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.Name: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.NullType: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.RefType: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.ShortType: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.VoidType: toString()
Ast.ShortType: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Ast.ShortType: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Ast.ShortType: productElement(x$1: Int) ===> Names.Env: toString()
Ast.ShortType: productElement(x$1: Int) ===> Names.MethodSig: toString()
Ast.ShortType: productElement(x$1: Int) ===> Parser.Leaf: toString()
Ast.ShortType: productElement(x$1: Int) ===> Parser.Node: toString()
Ast.ShortType: productElement(x$1: Int) ===> Parser.Production: toString()
Ast.ShortType: productElement(x$1: Int) ===> Parser.Reduce: toString()
Ast.ShortType: productElement(x$1: Int) ===> Parser.Shift: toString()
Ast.ShortType: productElement(x$1: Int) ===> Scanner.Token: toString()
Ast.ShortType: productElement(x$1: Int) ===> Util$Memoize: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.ByteType: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.CharType: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.IntType: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.Modifier: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.Name: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.NullType: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.RefType: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.ShortType: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.VoidType: toString()
Ast.Static: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Ast.Static: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Ast.Static: productElement(x$1: Int) ===> Names.Env: toString()
Ast.Static: productElement(x$1: Int) ===> Names.MethodSig: toString()
Ast.Static: productElement(x$1: Int) ===> Parser.Leaf: toString()
Ast.Static: productElement(x$1: Int) ===> Parser.Node: toString()
Ast.Static: productElement(x$1: Int) ===> Parser.Production: toString()
Ast.Static: productElement(x$1: Int) ===> Parser.Reduce: toString()
Ast.Static: productElement(x$1: Int) ===> Parser.Shift: toString()
Ast.Static: productElement(x$1: Int) ===> Scanner.Token: toString()
Ast.Static: productElement(x$1: Int) ===> Util$Memoize: toString()
Ast.TypeExpr: toString() ===> Ast.ArrayType: toString()
Ast.TypeExpr: toString() ===> Ast.BinExpr: toString()
Ast.TypeExpr: toString() ===> Ast.BooleanType: toString()
Ast.TypeExpr: toString() ===> Ast.ByteType: toString()
Ast.TypeExpr: toString() ===> Ast.CharType: toString()
Ast.TypeExpr: toString() ===> Ast.ClassDecl: toString()
Ast.TypeExpr: toString() ===> Ast.ExprStmt: toString()
Ast.TypeExpr: toString() ===> Ast.FieldDecl: toString()
Ast.TypeExpr: toString() ===> Ast.FieldExpr: toString()
Ast.TypeExpr: toString() ===> Ast.ForStmt: toString()
Ast.TypeExpr: toString() ===> Ast.IfStmt: toString()
Ast.TypeExpr: toString() ===> Ast.ImportClass: toString()
Ast.TypeExpr: toString() ===> Ast.ImportStar: toString()
Ast.TypeExpr: toString() ===> Ast.InstanceOfExpr: toString()
Ast.TypeExpr: toString() ===> Ast.IntType: toString()
Ast.TypeExpr: toString() ===> Ast.InvokeExpr: toString()
Ast.TypeExpr: toString() ===> Ast.MethodDecl: toString()
Ast.TypeExpr: toString() ===> Ast.Modifier: toString()
Ast.TypeExpr: toString() ===> Ast.Name: toString()
Ast.TypeExpr: toString() ===> Ast.NewExpr: toString()
Ast.TypeExpr: toString() ===> Ast.NullType: toString()
Ast.TypeExpr: toString() ===> Ast.RefType: toString()
Ast.TypeExpr: toString() ===> Ast.ReturnStmt: toString()
Ast.TypeExpr: toString() ===> Ast.ShortType: toString()
Ast.TypeExpr: toString() ===> Ast.ThisLiteral: toString()
Ast.TypeExpr: toString() ===> Ast.TypeExpr: toString()
Ast.TypeExpr: toString() ===> Ast.VarDeclStmt: toString()
Ast.TypeExpr: toString() ===> Ast.VarExpr: toString()
Ast.TypeExpr: toString() ===> Ast.VoidType: toString()
Ast.TypeExpr: toString() ===> Ast.WhileStmt: toString()
Ast.TypeExpr: toString() ===> Names.ConstrSig: toString()
Ast.TypeExpr: toString() ===> Names.Env: toString()
Ast.TypeExpr: toString() ===> Names.MethodSig: toString()
Ast.TypeExpr: toString() ===> Parser.Leaf: toString()
Ast.TypeExpr: toString() ===> Parser.Node: toString()
Ast.TypeExpr: toString() ===> Parser.Production: toString()
Ast.TypeExpr: toString() ===> Parser.Reduce: toString()
Ast.TypeExpr: toString() ===> Parser.Shift: toString()
Ast.TypeExpr: toString() ===> Scanner.Token: toString()
Ast.TypeExpr: toString() ===> Util$Memoize: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.ByteType: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.CharType: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.IntType: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.Modifier: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.Name: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.NullType: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.RefType: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.ShortType: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.VoidType: toString()
Ast.VoidType: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Ast.VoidType: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Ast.VoidType: productElement(x$1: Int) ===> Names.Env: toString()
Ast.VoidType: productElement(x$1: Int) ===> Names.MethodSig: toString()
Ast.VoidType: productElement(x$1: Int) ===> Parser.Leaf: toString()
Ast.VoidType: productElement(x$1: Int) ===> Parser.Node: toString()
Ast.VoidType: productElement(x$1: Int) ===> Parser.Production: toString()
Ast.VoidType: productElement(x$1: Int) ===> Parser.Reduce: toString()
Ast.VoidType: productElement(x$1: Int) ===> Parser.Shift: toString()
Ast.VoidType: productElement(x$1: Int) ===> Scanner.Token: toString()
Ast.VoidType: productElement(x$1: Int) ===> Util$Memoize: toString()
Ast: ast_AbstractMethodDeclaration(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_AbstractMethodDeclaration(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_AbstractMethodDeclaration(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_AbstractMethodDeclaration(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_AbstractMethodDeclaration(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_AbstractMethodDeclaration(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_AbstractMethodDeclaration(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_AbstractMethodDeclaration(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_AbstractMethodDeclaration(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_AbstractMethodDeclaration(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_AbstractMethodDeclaration(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_AbstractMethodDeclaration(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_AbstractMethodDeclaration(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_AdditiveExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_AdditiveExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_AdditiveExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_AdditiveExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_AdditiveExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_AdditiveExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_AdditiveExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_AdditiveExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_AdditiveExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_AdditiveExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_AdditiveExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_AdditiveExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_AdditiveExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_AndExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_AndExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_AndExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_AndExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_AndExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_AndExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_AndExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_AndExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_AndExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_AndExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_AndExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_AndExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_AndExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ArgumentList(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ArgumentList(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ArgumentList(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ArgumentList(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ArgumentList(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ArgumentList(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ArgumentList(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ArgumentList(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ArgumentList(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ArgumentList(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ArgumentList(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ArgumentList(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ArgumentList(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ArgumentListopt(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ArgumentListopt(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ArgumentListopt(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ArgumentListopt(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ArgumentListopt(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ArgumentListopt(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ArgumentListopt(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ArgumentListopt(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ArgumentListopt(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ArgumentListopt(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ArgumentListopt(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ArgumentListopt(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ArgumentListopt(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ArrayAccess(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ArrayAccess(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ArrayAccess(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ArrayAccess(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ArrayAccess(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ArrayAccess(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ArrayAccess(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ArrayAccess(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ArrayAccess(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ArrayAccess(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ArrayAccess(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ArrayAccess(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ArrayAccess(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ArrayCreationExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ArrayCreationExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ArrayCreationExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ArrayCreationExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ArrayCreationExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ArrayCreationExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ArrayCreationExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ArrayCreationExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ArrayCreationExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ArrayCreationExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ArrayCreationExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ArrayCreationExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ArrayCreationExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ArrayType(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ArrayType(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ArrayType(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ArrayType(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ArrayType(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ArrayType(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ArrayType(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ArrayType(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ArrayType(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ArrayType(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ArrayType(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ArrayType(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ArrayType(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Assignment(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Assignment(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Assignment(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Assignment(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Assignment(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Assignment(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Assignment(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Assignment(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Assignment(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Assignment(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Assignment(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Assignment(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Assignment(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_AssignmentExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_AssignmentExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_AssignmentExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_AssignmentExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_AssignmentExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_AssignmentExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_AssignmentExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_AssignmentExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_AssignmentExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_AssignmentExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_AssignmentExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_AssignmentExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_AssignmentExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Block(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Block(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Block(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Block(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Block(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Block(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Block(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Block(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Block(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Block(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Block(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Block(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Block(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_BlockStatement(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_BlockStatement(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_BlockStatement(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_BlockStatement(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_BlockStatement(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_BlockStatement(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_BlockStatement(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_BlockStatement(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_BlockStatement(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_BlockStatement(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_BlockStatement(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_BlockStatement(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_BlockStatement(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_BlockStatements(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_BlockStatements(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_BlockStatements(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_BlockStatements(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_BlockStatements(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_BlockStatements(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_BlockStatements(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_BlockStatements(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_BlockStatements(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_BlockStatements(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_BlockStatements(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_BlockStatements(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_BlockStatements(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_CastExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_CastExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_CastExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_CastExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_CastExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_CastExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_CastExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_CastExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_CastExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_CastExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_CastExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_CastExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_CastExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ClassBody(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ClassBody(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ClassBody(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ClassBody(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ClassBody(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ClassBody(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ClassBody(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ClassBody(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ClassBody(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ClassBody(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ClassBody(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ClassBody(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ClassBody(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ClassBodyDeclaration(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ClassBodyDeclaration(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ClassBodyDeclaration(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ClassBodyDeclaration(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ClassBodyDeclaration(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ClassBodyDeclaration(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ClassBodyDeclaration(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ClassBodyDeclaration(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ClassBodyDeclaration(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ClassBodyDeclaration(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ClassBodyDeclaration(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ClassBodyDeclaration(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ClassBodyDeclaration(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ClassBodyDeclarations(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ClassBodyDeclarations(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ClassBodyDeclarations(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ClassBodyDeclarations(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ClassBodyDeclarations(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ClassBodyDeclarations(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ClassBodyDeclarations(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ClassBodyDeclarations(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ClassBodyDeclarations(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ClassBodyDeclarations(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ClassBodyDeclarations(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ClassBodyDeclarations(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ClassBodyDeclarations(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ClassBodyDeclarationsopt(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ClassBodyDeclarationsopt(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ClassBodyDeclarationsopt(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ClassBodyDeclarationsopt(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ClassBodyDeclarationsopt(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ClassBodyDeclarationsopt(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ClassBodyDeclarationsopt(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ClassBodyDeclarationsopt(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ClassBodyDeclarationsopt(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ClassBodyDeclarationsopt(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ClassBodyDeclarationsopt(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ClassBodyDeclarationsopt(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ClassBodyDeclarationsopt(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ClassDeclaration(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ClassDeclaration(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ClassDeclaration(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ClassDeclaration(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ClassDeclaration(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ClassDeclaration(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ClassDeclaration(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ClassDeclaration(tree: Parser.Tree) ===> Parser$Node: asLeaf()
Ast: ast_ClassDeclaration(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ClassDeclaration(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ClassDeclaration(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ClassDeclaration(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ClassDeclaration(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ClassDeclaration(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ClassInstanceCreationExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ClassInstanceCreationExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ClassInstanceCreationExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ClassInstanceCreationExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ClassInstanceCreationExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ClassInstanceCreationExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ClassInstanceCreationExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ClassInstanceCreationExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ClassInstanceCreationExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ClassInstanceCreationExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ClassInstanceCreationExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ClassInstanceCreationExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ClassInstanceCreationExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ClassMemberDeclaration(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ClassMemberDeclaration(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ClassMemberDeclaration(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ClassMemberDeclaration(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ClassMemberDeclaration(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ClassMemberDeclaration(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ClassMemberDeclaration(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ClassMemberDeclaration(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ClassMemberDeclaration(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ClassMemberDeclaration(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ClassMemberDeclaration(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ClassMemberDeclaration(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ClassMemberDeclaration(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ClassOrInterfaceType(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ClassOrInterfaceType(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ClassOrInterfaceType(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ClassOrInterfaceType(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ClassOrInterfaceType(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ClassOrInterfaceType(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ClassOrInterfaceType(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ClassOrInterfaceType(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ClassOrInterfaceType(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ClassOrInterfaceType(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ClassOrInterfaceType(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ClassOrInterfaceType(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ClassOrInterfaceType(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ClassType(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ClassType(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ClassType(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ClassType(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ClassType(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ClassType(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ClassType(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ClassType(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ClassType(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ClassType(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ClassType(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ClassType(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ClassType(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ClassTypeList(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ClassTypeList(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ClassTypeList(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ClassTypeList(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ClassTypeList(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ClassTypeList(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ClassTypeList(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ClassTypeList(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ClassTypeList(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ClassTypeList(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ClassTypeList(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ClassTypeList(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ClassTypeList(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_CompilationUnit(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_CompilationUnit(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_CompilationUnit(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_CompilationUnit(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_CompilationUnit(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_CompilationUnit(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_CompilationUnit(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_CompilationUnit(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_CompilationUnit(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_CompilationUnit(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_CompilationUnit(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_CompilationUnit(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_CompilationUnit(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ConditionalAndExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ConditionalAndExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ConditionalAndExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ConditionalAndExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ConditionalAndExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ConditionalAndExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ConditionalAndExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ConditionalAndExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ConditionalAndExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ConditionalAndExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ConditionalAndExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ConditionalAndExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ConditionalAndExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ConditionalOrExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ConditionalOrExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ConditionalOrExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ConditionalOrExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ConditionalOrExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ConditionalOrExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ConditionalOrExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ConditionalOrExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ConditionalOrExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ConditionalOrExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ConditionalOrExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ConditionalOrExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ConditionalOrExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ConstructorBody(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ConstructorBody(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ConstructorBody(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ConstructorBody(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ConstructorBody(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ConstructorBody(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ConstructorBody(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ConstructorBody(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ConstructorBody(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ConstructorBody(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ConstructorBody(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ConstructorBody(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ConstructorBody(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ConstructorDeclaration(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ConstructorDeclaration(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ConstructorDeclaration(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ConstructorDeclaration(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ConstructorDeclaration(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ConstructorDeclaration(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ConstructorDeclaration(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ConstructorDeclaration(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ConstructorDeclaration(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ConstructorDeclaration(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ConstructorDeclaration(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ConstructorDeclaration(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ConstructorDeclaration(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ConstructorDeclarator(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ConstructorDeclarator(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ConstructorDeclarator(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ConstructorDeclarator(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ConstructorDeclarator(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ConstructorDeclarator(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ConstructorDeclarator(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ConstructorDeclarator(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ConstructorDeclarator(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ConstructorDeclarator(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ConstructorDeclarator(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ConstructorDeclarator(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ConstructorDeclarator(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_DimExpr(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_DimExpr(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_DimExpr(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_DimExpr(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_DimExpr(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_DimExpr(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_DimExpr(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_DimExpr(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_DimExpr(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_DimExpr(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_DimExpr(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_DimExpr(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_DimExpr(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_DimExprs(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_DimExprs(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_DimExprs(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_DimExprs(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_DimExprs(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_DimExprs(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_DimExprs(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_DimExprs(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_DimExprs(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_DimExprs(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_DimExprs(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_DimExprs(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_DimExprs(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Dims(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Dims(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Dims(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Dims(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Dims(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Dims(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Dims(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Dims(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Dims(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Dims(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Dims(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Dims(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Dims(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Dimsopt(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Dimsopt(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Dimsopt(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Dimsopt(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Dimsopt(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Dimsopt(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Dimsopt(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Dimsopt(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Dimsopt(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Dimsopt(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Dimsopt(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Dimsopt(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Dimsopt(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_EmptyStatement(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_EmptyStatement(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_EmptyStatement(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_EmptyStatement(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_EmptyStatement(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_EmptyStatement(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_EmptyStatement(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_EmptyStatement(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_EmptyStatement(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_EmptyStatement(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_EmptyStatement(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_EmptyStatement(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_EmptyStatement(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_EqualityExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_EqualityExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_EqualityExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_EqualityExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_EqualityExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_EqualityExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_EqualityExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_EqualityExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_EqualityExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_EqualityExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_EqualityExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_EqualityExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_EqualityExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ExclusiveOrExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ExclusiveOrExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ExclusiveOrExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ExclusiveOrExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ExclusiveOrExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ExclusiveOrExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ExclusiveOrExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ExclusiveOrExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ExclusiveOrExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ExclusiveOrExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ExclusiveOrExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ExclusiveOrExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ExclusiveOrExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Expression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Expression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Expression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Expression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Expression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Expression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Expression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Expression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Expression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Expression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Expression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Expression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Expression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Expressionopt(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Expressionopt(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Expressionopt(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Expressionopt(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Expressionopt(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Expressionopt(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Expressionopt(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Expressionopt(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Expressionopt(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Expressionopt(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Expressionopt(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Expressionopt(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Expressionopt(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ExpressionStatement(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ExpressionStatement(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ExpressionStatement(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ExpressionStatement(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ExpressionStatement(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ExpressionStatement(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ExpressionStatement(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ExpressionStatement(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ExpressionStatement(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ExpressionStatement(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ExpressionStatement(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ExpressionStatement(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ExpressionStatement(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ExtendsInterfaces(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ExtendsInterfaces(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ExtendsInterfaces(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ExtendsInterfaces(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ExtendsInterfaces(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ExtendsInterfaces(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ExtendsInterfaces(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ExtendsInterfaces(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ExtendsInterfaces(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ExtendsInterfaces(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ExtendsInterfaces(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ExtendsInterfaces(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ExtendsInterfaces(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ExtendsInterfacesopt(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ExtendsInterfacesopt(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ExtendsInterfacesopt(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ExtendsInterfacesopt(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ExtendsInterfacesopt(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ExtendsInterfacesopt(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ExtendsInterfacesopt(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ExtendsInterfacesopt(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ExtendsInterfacesopt(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ExtendsInterfacesopt(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ExtendsInterfacesopt(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ExtendsInterfacesopt(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ExtendsInterfacesopt(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_FieldAccess(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_FieldAccess(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_FieldAccess(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_FieldAccess(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_FieldAccess(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_FieldAccess(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_FieldAccess(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_FieldAccess(tree: Parser.Tree) ===> Parser$Node: asLeaf()
Ast: ast_FieldAccess(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_FieldAccess(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_FieldAccess(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_FieldAccess(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_FieldAccess(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_FieldAccess(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_FieldDeclaration(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_FieldDeclaration(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_FieldDeclaration(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_FieldDeclaration(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_FieldDeclaration(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_FieldDeclaration(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_FieldDeclaration(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_FieldDeclaration(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_FieldDeclaration(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_FieldDeclaration(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_FieldDeclaration(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_FieldDeclaration(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_FieldDeclaration(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ForInit(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ForInit(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ForInit(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ForInit(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ForInit(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ForInit(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ForInit(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ForInit(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ForInit(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ForInit(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ForInit(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ForInit(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ForInit(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ForInitopt(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ForInitopt(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ForInitopt(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ForInitopt(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ForInitopt(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ForInitopt(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ForInitopt(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ForInitopt(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ForInitopt(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ForInitopt(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ForInitopt(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ForInitopt(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ForInitopt(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_FormalParameter(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_FormalParameter(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_FormalParameter(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_FormalParameter(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_FormalParameter(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_FormalParameter(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_FormalParameter(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_FormalParameter(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_FormalParameter(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_FormalParameter(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_FormalParameter(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_FormalParameter(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_FormalParameter(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_FormalParameterList(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_FormalParameterList(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_FormalParameterList(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_FormalParameterList(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_FormalParameterList(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_FormalParameterList(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_FormalParameterList(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_FormalParameterList(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_FormalParameterList(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_FormalParameterList(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_FormalParameterList(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_FormalParameterList(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_FormalParameterList(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_FormalParameterListopt(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_FormalParameterListopt(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_FormalParameterListopt(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_FormalParameterListopt(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_FormalParameterListopt(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_FormalParameterListopt(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_FormalParameterListopt(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_FormalParameterListopt(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_FormalParameterListopt(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_FormalParameterListopt(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_FormalParameterListopt(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_FormalParameterListopt(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_FormalParameterListopt(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ForStatement(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ForStatement(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ForStatement(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ForStatement(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ForStatement(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ForStatement(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ForStatement(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ForStatement(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ForStatement(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ForStatement(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ForStatement(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ForStatement(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ForStatement(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ForStatementNoShortIf(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ForStatementNoShortIf(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ForStatementNoShortIf(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ForStatementNoShortIf(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ForStatementNoShortIf(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ForStatementNoShortIf(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ForStatementNoShortIf(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ForStatementNoShortIf(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ForStatementNoShortIf(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ForStatementNoShortIf(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ForStatementNoShortIf(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ForStatementNoShortIf(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ForStatementNoShortIf(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ForUpdate(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ForUpdate(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ForUpdate(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ForUpdate(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ForUpdate(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ForUpdate(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ForUpdate(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ForUpdate(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ForUpdate(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ForUpdate(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ForUpdate(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ForUpdate(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ForUpdate(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ForUpdateopt(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ForUpdateopt(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ForUpdateopt(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ForUpdateopt(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ForUpdateopt(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ForUpdateopt(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ForUpdateopt(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ForUpdateopt(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ForUpdateopt(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ForUpdateopt(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ForUpdateopt(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ForUpdateopt(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ForUpdateopt(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_IfThenElseStatement(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_IfThenElseStatement(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_IfThenElseStatement(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_IfThenElseStatement(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_IfThenElseStatement(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_IfThenElseStatement(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_IfThenElseStatement(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_IfThenElseStatement(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_IfThenElseStatement(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_IfThenElseStatement(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_IfThenElseStatement(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_IfThenElseStatement(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_IfThenElseStatement(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_IfThenElseStatementNoShortIf(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_IfThenElseStatementNoShortIf(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_IfThenElseStatementNoShortIf(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_IfThenElseStatementNoShortIf(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_IfThenElseStatementNoShortIf(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_IfThenElseStatementNoShortIf(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_IfThenElseStatementNoShortIf(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_IfThenElseStatementNoShortIf(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_IfThenElseStatementNoShortIf(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_IfThenElseStatementNoShortIf(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_IfThenElseStatementNoShortIf(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_IfThenElseStatementNoShortIf(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_IfThenElseStatementNoShortIf(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_IfThenStatement(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_IfThenStatement(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_IfThenStatement(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_IfThenStatement(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_IfThenStatement(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_IfThenStatement(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_IfThenStatement(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_IfThenStatement(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_IfThenStatement(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_IfThenStatement(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_IfThenStatement(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_IfThenStatement(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_IfThenStatement(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ImportDeclaration(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ImportDeclaration(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ImportDeclaration(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ImportDeclaration(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ImportDeclaration(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ImportDeclaration(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ImportDeclaration(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ImportDeclaration(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ImportDeclaration(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ImportDeclaration(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ImportDeclaration(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ImportDeclaration(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ImportDeclaration(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ImportDeclarations(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ImportDeclarations(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ImportDeclarations(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ImportDeclarations(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ImportDeclarations(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ImportDeclarations(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ImportDeclarations(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ImportDeclarations(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ImportDeclarations(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ImportDeclarations(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ImportDeclarations(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ImportDeclarations(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ImportDeclarations(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ImportDeclarationsopt(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ImportDeclarationsopt(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ImportDeclarationsopt(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ImportDeclarationsopt(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ImportDeclarationsopt(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ImportDeclarationsopt(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ImportDeclarationsopt(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ImportDeclarationsopt(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ImportDeclarationsopt(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ImportDeclarationsopt(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ImportDeclarationsopt(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ImportDeclarationsopt(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ImportDeclarationsopt(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_InclusiveOrExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_InclusiveOrExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_InclusiveOrExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_InclusiveOrExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_InclusiveOrExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_InclusiveOrExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_InclusiveOrExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_InclusiveOrExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_InclusiveOrExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_InclusiveOrExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_InclusiveOrExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_InclusiveOrExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_InclusiveOrExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_IntegralType(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_IntegralType(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_IntegralType(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_IntegralType(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_IntegralType(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_IntegralType(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_IntegralType(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_IntegralType(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_IntegralType(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_IntegralType(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_IntegralType(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_IntegralType(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_IntegralType(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_InterfaceBody(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_InterfaceBody(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_InterfaceBody(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_InterfaceBody(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_InterfaceBody(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_InterfaceBody(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_InterfaceBody(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_InterfaceBody(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_InterfaceBody(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_InterfaceBody(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_InterfaceBody(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_InterfaceBody(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_InterfaceBody(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_InterfaceDeclaration(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_InterfaceDeclaration(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_InterfaceDeclaration(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_InterfaceDeclaration(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_InterfaceDeclaration(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_InterfaceDeclaration(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_InterfaceDeclaration(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_InterfaceDeclaration(tree: Parser.Tree) ===> Parser$Node: asLeaf()
Ast: ast_InterfaceDeclaration(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_InterfaceDeclaration(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_InterfaceDeclaration(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_InterfaceDeclaration(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_InterfaceDeclaration(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_InterfaceDeclaration(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclaration(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclaration(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclaration(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclaration(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclaration(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclaration(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclaration(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclaration(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclaration(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclaration(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclaration(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclaration(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclaration(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarations(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarations(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarations(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarations(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarations(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarations(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarations(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarations(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarations(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarations(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarations(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarations(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarations(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarationsopt(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarationsopt(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarationsopt(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarationsopt(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarationsopt(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarationsopt(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarationsopt(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarationsopt(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarationsopt(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarationsopt(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarationsopt(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarationsopt(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_InterfaceMemberDeclarationsopt(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Interfaces(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Interfaces(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Interfaces(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Interfaces(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Interfaces(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Interfaces(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Interfaces(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Interfaces(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Interfaces(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Interfaces(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Interfaces(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Interfaces(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Interfaces(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Interfacesopt(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Interfacesopt(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Interfacesopt(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Interfacesopt(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Interfacesopt(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Interfacesopt(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Interfacesopt(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Interfacesopt(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Interfacesopt(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Interfacesopt(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Interfacesopt(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Interfacesopt(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Interfacesopt(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_InterfaceType(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_InterfaceType(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_InterfaceType(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_InterfaceType(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_InterfaceType(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_InterfaceType(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_InterfaceType(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_InterfaceType(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_InterfaceType(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_InterfaceType(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_InterfaceType(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_InterfaceType(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_InterfaceType(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_InterfaceTypeList(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_InterfaceTypeList(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_InterfaceTypeList(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_InterfaceTypeList(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_InterfaceTypeList(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_InterfaceTypeList(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_InterfaceTypeList(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_InterfaceTypeList(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_InterfaceTypeList(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_InterfaceTypeList(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_InterfaceTypeList(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_InterfaceTypeList(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_InterfaceTypeList(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_LeftHandSide(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_LeftHandSide(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_LeftHandSide(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_LeftHandSide(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_LeftHandSide(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_LeftHandSide(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_LeftHandSide(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_LeftHandSide(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_LeftHandSide(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_LeftHandSide(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_LeftHandSide(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_LeftHandSide(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_LeftHandSide(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Literal(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Literal(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Literal(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Literal(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Literal(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Literal(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Literal(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Literal(tree: Parser.Tree) ===> Parser$Node: asLeaf()
Ast: ast_Literal(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Literal(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Literal(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Literal(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Literal(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Literal(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_LocalVariableDeclaration(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_LocalVariableDeclaration(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_LocalVariableDeclaration(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_LocalVariableDeclaration(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_LocalVariableDeclaration(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_LocalVariableDeclaration(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_LocalVariableDeclaration(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_LocalVariableDeclaration(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_LocalVariableDeclaration(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_LocalVariableDeclaration(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_LocalVariableDeclaration(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_LocalVariableDeclaration(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_LocalVariableDeclaration(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_LocalVariableDeclarationStatement(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_LocalVariableDeclarationStatement(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_LocalVariableDeclarationStatement(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_LocalVariableDeclarationStatement(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_LocalVariableDeclarationStatement(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_LocalVariableDeclarationStatement(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_LocalVariableDeclarationStatement(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_LocalVariableDeclarationStatement(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_LocalVariableDeclarationStatement(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_LocalVariableDeclarationStatement(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_LocalVariableDeclarationStatement(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_LocalVariableDeclarationStatement(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_LocalVariableDeclarationStatement(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_MethodBody(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_MethodBody(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_MethodBody(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_MethodBody(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_MethodBody(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_MethodBody(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_MethodBody(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_MethodBody(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_MethodBody(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_MethodBody(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_MethodBody(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_MethodBody(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_MethodBody(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_MethodDeclaration(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_MethodDeclaration(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_MethodDeclaration(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_MethodDeclaration(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_MethodDeclaration(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_MethodDeclaration(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_MethodDeclaration(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_MethodDeclaration(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_MethodDeclaration(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_MethodDeclaration(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_MethodDeclaration(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_MethodDeclaration(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_MethodDeclaration(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_MethodDeclarator(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_MethodDeclarator(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_MethodDeclarator(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_MethodDeclarator(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_MethodDeclarator(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_MethodDeclarator(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_MethodDeclarator(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_MethodDeclarator(tree: Parser.Tree) ===> Parser$Node: asLeaf()
Ast: ast_MethodDeclarator(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_MethodDeclarator(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_MethodDeclarator(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_MethodDeclarator(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_MethodDeclarator(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_MethodDeclarator(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_MethodHeader(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_MethodHeader(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_MethodHeader(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_MethodHeader(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_MethodHeader(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_MethodHeader(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_MethodHeader(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_MethodHeader(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_MethodHeader(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_MethodHeader(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_MethodHeader(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_MethodHeader(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_MethodHeader(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_MethodInvocation(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_MethodInvocation(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_MethodInvocation(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_MethodInvocation(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_MethodInvocation(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_MethodInvocation(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_MethodInvocation(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_MethodInvocation(tree: Parser.Tree) ===> Parser$Node: asLeaf()
Ast: ast_MethodInvocation(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_MethodInvocation(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_MethodInvocation(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_MethodInvocation(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_MethodInvocation(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_MethodInvocation(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Modifier(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Modifier(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Modifier(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Modifier(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Modifier(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Modifier(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Modifier(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Modifier(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Modifier(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Modifier(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Modifier(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Modifier(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Modifier(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Modifiers(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Modifiers(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Modifiers(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Modifiers(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Modifiers(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Modifiers(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Modifiers(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Modifiers(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Modifiers(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Modifiers(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Modifiers(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Modifiers(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Modifiers(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_MultiplicativeExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_MultiplicativeExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_MultiplicativeExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_MultiplicativeExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_MultiplicativeExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_MultiplicativeExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_MultiplicativeExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_MultiplicativeExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_MultiplicativeExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_MultiplicativeExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_MultiplicativeExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_MultiplicativeExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_MultiplicativeExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Name(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Name(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Name(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Name(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Name(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Name(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Name(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Name(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Name(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Name(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Name(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Name(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Name(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_NumericType(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_NumericType(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_NumericType(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_NumericType(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_NumericType(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_NumericType(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_NumericType(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_NumericType(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_NumericType(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_NumericType(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_NumericType(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_NumericType(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_NumericType(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_PackageDeclaration(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_PackageDeclaration(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_PackageDeclaration(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_PackageDeclaration(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_PackageDeclaration(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_PackageDeclaration(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_PackageDeclaration(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_PackageDeclaration(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_PackageDeclaration(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_PackageDeclaration(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_PackageDeclaration(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_PackageDeclaration(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_PackageDeclaration(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_PackageDeclarationopt(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_PackageDeclarationopt(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_PackageDeclarationopt(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_PackageDeclarationopt(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_PackageDeclarationopt(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_PackageDeclarationopt(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_PackageDeclarationopt(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_PackageDeclarationopt(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_PackageDeclarationopt(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_PackageDeclarationopt(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_PackageDeclarationopt(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_PackageDeclarationopt(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_PackageDeclarationopt(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_PostDecrementExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_PostDecrementExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_PostDecrementExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_PostDecrementExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_PostDecrementExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_PostDecrementExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_PostDecrementExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_PostDecrementExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_PostDecrementExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_PostDecrementExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_PostDecrementExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_PostDecrementExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_PostDecrementExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_PostfixExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_PostfixExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_PostfixExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_PostfixExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_PostfixExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_PostfixExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_PostfixExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_PostfixExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_PostfixExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_PostfixExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_PostfixExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_PostfixExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_PostfixExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_PostIncrementExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_PostIncrementExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_PostIncrementExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_PostIncrementExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_PostIncrementExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_PostIncrementExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_PostIncrementExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_PostIncrementExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_PostIncrementExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_PostIncrementExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_PostIncrementExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_PostIncrementExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_PostIncrementExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_PreDecrementExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_PreDecrementExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_PreDecrementExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_PreDecrementExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_PreDecrementExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_PreDecrementExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_PreDecrementExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_PreDecrementExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_PreDecrementExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_PreDecrementExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_PreDecrementExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_PreDecrementExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_PreDecrementExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_PreIncrementExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_PreIncrementExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_PreIncrementExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_PreIncrementExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_PreIncrementExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_PreIncrementExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_PreIncrementExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_PreIncrementExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_PreIncrementExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_PreIncrementExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_PreIncrementExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_PreIncrementExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_PreIncrementExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Primary(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Primary(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Primary(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Primary(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Primary(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Primary(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Primary(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Primary(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Primary(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Primary(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Primary(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Primary(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Primary(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_PrimaryNoNewArray(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_PrimaryNoNewArray(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_PrimaryNoNewArray(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_PrimaryNoNewArray(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_PrimaryNoNewArray(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_PrimaryNoNewArray(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_PrimaryNoNewArray(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_PrimaryNoNewArray(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_PrimaryNoNewArray(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_PrimaryNoNewArray(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_PrimaryNoNewArray(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_PrimaryNoNewArray(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_PrimaryNoNewArray(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_PrimitiveType(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_PrimitiveType(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_PrimitiveType(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_PrimitiveType(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_PrimitiveType(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_PrimitiveType(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_PrimitiveType(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_PrimitiveType(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_PrimitiveType(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_PrimitiveType(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_PrimitiveType(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_PrimitiveType(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_PrimitiveType(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_QualifiedName(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_QualifiedName(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_QualifiedName(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_QualifiedName(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_QualifiedName(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_QualifiedName(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_QualifiedName(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_QualifiedName(tree: Parser.Tree) ===> Parser$Node: asLeaf()
Ast: ast_QualifiedName(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_QualifiedName(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_QualifiedName(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_QualifiedName(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_QualifiedName(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_QualifiedName(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ReferenceType(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ReferenceType(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ReferenceType(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ReferenceType(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ReferenceType(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ReferenceType(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ReferenceType(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ReferenceType(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ReferenceType(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ReferenceType(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ReferenceType(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ReferenceType(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ReferenceType(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_RelationalExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_RelationalExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_RelationalExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_RelationalExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_RelationalExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_RelationalExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_RelationalExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_RelationalExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_RelationalExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_RelationalExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_RelationalExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_RelationalExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_RelationalExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_ReturnStatement(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_ReturnStatement(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_ReturnStatement(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_ReturnStatement(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_ReturnStatement(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_ReturnStatement(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_ReturnStatement(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_ReturnStatement(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_ReturnStatement(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_ReturnStatement(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_ReturnStatement(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_ReturnStatement(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_ReturnStatement(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_SimpleName(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_SimpleName(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_SimpleName(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_SimpleName(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_SimpleName(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_SimpleName(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_SimpleName(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_SimpleName(tree: Parser.Tree) ===> Parser$Node: asLeaf()
Ast: ast_SimpleName(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_SimpleName(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_SimpleName(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_SimpleName(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_SimpleName(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_SimpleName(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_SingleTypeImportDeclaration(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_SingleTypeImportDeclaration(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_SingleTypeImportDeclaration(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_SingleTypeImportDeclaration(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_SingleTypeImportDeclaration(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_SingleTypeImportDeclaration(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_SingleTypeImportDeclaration(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_SingleTypeImportDeclaration(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_SingleTypeImportDeclaration(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_SingleTypeImportDeclaration(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_SingleTypeImportDeclaration(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_SingleTypeImportDeclaration(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_SingleTypeImportDeclaration(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Statement(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Statement(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Statement(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Statement(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Statement(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Statement(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Statement(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Statement(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Statement(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Statement(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Statement(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Statement(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Statement(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_StatementExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_StatementExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_StatementExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_StatementExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_StatementExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_StatementExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_StatementExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_StatementExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_StatementExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_StatementExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_StatementExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_StatementExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_StatementExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_StatementNoShortIf(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_StatementNoShortIf(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_StatementNoShortIf(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_StatementNoShortIf(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_StatementNoShortIf(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_StatementNoShortIf(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_StatementNoShortIf(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_StatementNoShortIf(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_StatementNoShortIf(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_StatementNoShortIf(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_StatementNoShortIf(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_StatementNoShortIf(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_StatementNoShortIf(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_StatementWithoutTrailingSubstatement(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_StatementWithoutTrailingSubstatement(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_StatementWithoutTrailingSubstatement(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_StatementWithoutTrailingSubstatement(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_StatementWithoutTrailingSubstatement(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_StatementWithoutTrailingSubstatement(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_StatementWithoutTrailingSubstatement(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_StatementWithoutTrailingSubstatement(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_StatementWithoutTrailingSubstatement(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_StatementWithoutTrailingSubstatement(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_StatementWithoutTrailingSubstatement(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_StatementWithoutTrailingSubstatement(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_StatementWithoutTrailingSubstatement(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Super(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Super(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Super(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Super(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Super(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Super(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Super(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Super(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Super(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Super(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Super(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Super(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Super(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Superopt(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Superopt(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Superopt(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Superopt(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Superopt(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Superopt(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Superopt(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Superopt(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Superopt(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Superopt(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Superopt(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Superopt(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Superopt(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Throws(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Throws(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Throws(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Throws(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Throws(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Throws(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Throws(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Throws(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Throws(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Throws(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Throws(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Throws(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Throws(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Throwsopt(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Throwsopt(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Throwsopt(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Throwsopt(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Throwsopt(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Throwsopt(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Throwsopt(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Throwsopt(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Throwsopt(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Throwsopt(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Throwsopt(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Throwsopt(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Throwsopt(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_Type(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_Type(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_Type(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_Type(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_Type(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_Type(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_Type(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_Type(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_Type(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_Type(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_Type(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_Type(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_Type(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_TypeDeclaration(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_TypeDeclaration(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_TypeDeclaration(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_TypeDeclaration(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_TypeDeclaration(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_TypeDeclaration(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_TypeDeclaration(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_TypeDeclaration(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_TypeDeclaration(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_TypeDeclaration(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_TypeDeclaration(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_TypeDeclaration(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_TypeDeclaration(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_TypeDeclarationopt(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_TypeDeclarationopt(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_TypeDeclarationopt(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_TypeDeclarationopt(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_TypeDeclarationopt(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_TypeDeclarationopt(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_TypeDeclarationopt(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_TypeDeclarationopt(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_TypeDeclarationopt(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_TypeDeclarationopt(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_TypeDeclarationopt(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_TypeDeclarationopt(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_TypeDeclarationopt(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_TypeImportOnDemandDeclaration(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_TypeImportOnDemandDeclaration(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_TypeImportOnDemandDeclaration(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_TypeImportOnDemandDeclaration(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_TypeImportOnDemandDeclaration(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_TypeImportOnDemandDeclaration(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_TypeImportOnDemandDeclaration(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_TypeImportOnDemandDeclaration(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_TypeImportOnDemandDeclaration(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_TypeImportOnDemandDeclaration(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_TypeImportOnDemandDeclaration(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_TypeImportOnDemandDeclaration(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_TypeImportOnDemandDeclaration(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_UnaryExpression(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_UnaryExpression(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_UnaryExpression(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_UnaryExpression(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_UnaryExpression(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_UnaryExpression(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_UnaryExpression(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_UnaryExpression(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_UnaryExpression(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_UnaryExpression(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_UnaryExpression(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_UnaryExpression(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_UnaryExpression(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_UnaryExpressionNotPlusMinus(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_UnaryExpressionNotPlusMinus(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_UnaryExpressionNotPlusMinus(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_UnaryExpressionNotPlusMinus(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_UnaryExpressionNotPlusMinus(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_UnaryExpressionNotPlusMinus(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_UnaryExpressionNotPlusMinus(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_UnaryExpressionNotPlusMinus(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_UnaryExpressionNotPlusMinus(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_UnaryExpressionNotPlusMinus(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_UnaryExpressionNotPlusMinus(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_UnaryExpressionNotPlusMinus(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_UnaryExpressionNotPlusMinus(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_VariableDeclarator(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_VariableDeclarator(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_VariableDeclarator(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_VariableDeclarator(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_VariableDeclarator(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_VariableDeclarator(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_VariableDeclarator(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_VariableDeclarator(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_VariableDeclarator(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_VariableDeclarator(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_VariableDeclarator(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_VariableDeclarator(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_VariableDeclarator(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_VariableDeclaratorId(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_VariableDeclaratorId(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_VariableDeclaratorId(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_VariableDeclaratorId(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_VariableDeclaratorId(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_VariableDeclaratorId(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_VariableDeclaratorId(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_VariableDeclaratorId(tree: Parser.Tree) ===> Parser$Node: asLeaf()
Ast: ast_VariableDeclaratorId(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_VariableDeclaratorId(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_VariableDeclaratorId(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_VariableDeclaratorId(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_VariableDeclaratorId(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_VariableDeclaratorId(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_VariableInitializer(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_VariableInitializer(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_VariableInitializer(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_VariableInitializer(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_VariableInitializer(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_VariableInitializer(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_VariableInitializer(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_VariableInitializer(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_VariableInitializer(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_VariableInitializer(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_VariableInitializer(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_VariableInitializer(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_VariableInitializer(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_WhileStatement(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_WhileStatement(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_WhileStatement(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_WhileStatement(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_WhileStatement(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_WhileStatement(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_WhileStatement(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_WhileStatement(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_WhileStatement(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_WhileStatement(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_WhileStatement(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_WhileStatement(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_WhileStatement(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: ast_WhileStatementNoShortIf(tree: Parser.Tree) ===> Ast.ArrayType: equals(x$1: Any)
Ast: ast_WhileStatementNoShortIf(tree: Parser.Tree) ===> Ast.ImportClass: equals(x$1: Any)
Ast: ast_WhileStatementNoShortIf(tree: Parser.Tree) ===> Ast.ImportStar: equals(x$1: Any)
Ast: ast_WhileStatementNoShortIf(tree: Parser.Tree) ===> Ast.Name: equals(x$1: Any)
Ast: ast_WhileStatementNoShortIf(tree: Parser.Tree) ===> Ast.RefType: equals(x$1: Any)
Ast: ast_WhileStatementNoShortIf(tree: Parser.Tree) ===> Names.ConstrSig: equals(x$1: Any)
Ast: ast_WhileStatementNoShortIf(tree: Parser.Tree) ===> Names.MethodSig: equals(x$1: Any)
Ast: ast_WhileStatementNoShortIf(tree: Parser.Tree) ===> Parser.Leaf: equals(x$1: Any)
Ast: ast_WhileStatementNoShortIf(tree: Parser.Tree) ===> Parser.Node: equals(x$1: Any)
Ast: ast_WhileStatementNoShortIf(tree: Parser.Tree) ===> Parser.Production: equals(x$1: Any)
Ast: ast_WhileStatementNoShortIf(tree: Parser.Tree) ===> Parser.Reduce: equals(x$1: Any)
Ast: ast_WhileStatementNoShortIf(tree: Parser.Tree) ===> Parser.Shift: equals(x$1: Any)
Ast: ast_WhileStatementNoShortIf(tree: Parser.Tree) ===> Scanner.Token: equals(x$1: Any)
Ast: check(s: String) ===> Ast.ArrayType: equals(x$1: Any)
Ast: check(s: String) ===> Ast.ImportClass: equals(x$1: Any)
Ast: check(s: String) ===> Ast.ImportStar: equals(x$1: Any)
Ast: check(s: String) ===> Ast.Name: equals(x$1: Any)
Ast: check(s: String) ===> Ast.RefType: equals(x$1: Any)
Ast: check(s: String) ===> Names.ConstrSig: equals(x$1: Any)
Ast: check(s: String) ===> Names.MethodSig: equals(x$1: Any)
Ast: check(s: String) ===> Parser$Leaf: asNode()
Ast: check(s: String) ===> Parser.Leaf: equals(x$1: Any)
Ast: check(s: String) ===> Parser.Node: equals(x$1: Any)
Ast: check(s: String) ===> Parser.Production: equals(x$1: Any)
Ast: check(s: String) ===> Parser.Reduce: equals(x$1: Any)
Ast: check(s: String) ===> Parser.Shift: equals(x$1: Any)
Ast: check(s: String) ===> Scanner.Token: equals(x$1: Any)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Ast$$anonfun$assertAllLinks$1$$anonfun$apply$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Ast$$anonfun$assertAllLinks$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Ast$$anonfun$assertLinks$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Ast$$anonfun$assertLinks$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Ast$$anonfun$ast_CastExpression$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Ast$$anonfun$ast_ClassDeclaration$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Ast$$anonfun$dfs$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Ast$$anonfun$expandEscapes$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Ast$$anonfun$main$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Ast$$anonfun$main$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Ast$AstNode$$anonfun$linkParents$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Ast$ConstructorDecl$$anonfun$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Ast$MethodDecl$$anonfun$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anon$2$$anonfun$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anon$3$$anonfun$8: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anon$3$$anonfun$code$4: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anon$4$$anonfun$code$5: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$7: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$9$$anonfun$apply$21: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$9$$anonfun$apply$22: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$9: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$arrayFrame$lzycompute$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$classFrame$lzycompute$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$3: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$4: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$5: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$15$$anonfun$apply$16: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$15: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$17: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$18: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$19$$anonfun$apply$20: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$19: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$6: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$13: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$10: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$11$$anonfun$apply$12: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$11: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$3: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$4: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$3: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$codeGen$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$constFrame$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$constFrame$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$constrSig$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$main$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$mainClass$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$makeFrame$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$makeFrame$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$methodFrame$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$methodFrame$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$methodSig$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$objectFrame$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$objectFrame$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$$anonfun$objectFrame$3: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$2$$anonfun$apply$3: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$interfaceInvoke$2$$anonfun$3: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$4: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$5: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$6: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$interfaceInvoke$2$$anonfun$code$3: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$subtypeTests$2$$anonfun$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$subtypeTests$2$$anonfun$code$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> CodeGen$subtypeTests$2$$anonfun$code$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> MakeAst$$anonfun$main$1$$anonfun$apply$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> MakeAst$$anonfun$main$1$$anonfun$apply$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> MakeAst$$anonfun$main$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$10: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$12$$anonfun$apply$76: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$12$$anonfun$apply$77: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$12: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$8: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$9: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$32: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$34: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$36: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$37: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$38: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addAbstractObjectMethods$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$39: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$40: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$11: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$43: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$44: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$45: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$46: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addAbstractObjectMethods$1$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addClasses$1$1$$anonfun$apply$5: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$addClasses$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$canonicalNames$1$1$$anonfun$apply$4: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$canonicalNames$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20$$anonfun$apply$21$$anonfun$apply$22: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20$$anonfun$apply$21: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkDemandPackageIsClass$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkHierarchyCycles$1$1$$anonfun$apply$31: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkHierarchyCycles$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$28: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$29$$anonfun$apply$30: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$29: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkInterfaceFields$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17$$anonfun$apply$18$$anonfun$apply$19: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17$$anonfun$apply$18: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkNonExistingPackage$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkPackageClashWithType$1$1$$anonfun$apply$25: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkPackageClashWithType$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkPrefixesOfReferences$1$1$$anonfun$apply$26: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkPrefixesOfReferences$1$1$$anonfun$apply$27: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkPrefixesOfReferences$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkSingleTypeImports$1$1$$anonfun$apply$15$$anonfun$apply$16: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkSingleTypeImports$1$1$$anonfun$apply$15: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$checkSingleTypeImports$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$demandImports$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$demImp$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$demImp$1$2$$anonfun$apply$23: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$demImp$1$2$$anonfun$apply$24: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$demImp$1$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$enclosingBlock$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$enclosingClass$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$environments$1$$anonfun$apply$14: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$environments$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$63: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$64: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$66: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$67: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$68: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$69: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$70: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$71: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$73: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$74: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$75: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$hierarchy$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$interfaces$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$isSubtype$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$main$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$makeEnvs$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$10: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$11: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$12$$anonfun$apply$13: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$12: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$6: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$7: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$8$$anonfun$apply$9: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$8: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$Names$$addMembers$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$Names$$dfs$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$resolveTypes$1$1$$anonfun$7: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$resolveTypes$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$singleImports$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$$anonfun$typeLinking$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$ConstrSig$$anonfun$apply$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$Env$$anonfun$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$Env$$anonfun$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$Env$$anonfun$4$$anonfun$apply$3: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$Env$$anonfun$5: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$Env$$anonfun$lookupClass$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$Env$$anonfun$Names$Env$$tryName$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$Env$$anonfun$resolveClass$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$FieldCheck$$anonfun$declare$3: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$FieldCheck$$anonfun$declare$4: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$FieldCheck$$anonfun$inherit$2$$anonfun$apply$61: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$FieldCheck$$anonfun$inherit$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$allabs$1$$anonfun$apply$47: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$allabs$1$$anonfun$apply$48: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$allabs$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$declare$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$declare$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$49: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$50: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$51: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$inherit$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$nodecl$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$replace$1$$anonfun$apply$53: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$replace$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$56: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$57: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$58: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$59: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$60: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$replace$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$replaceM$1$$anonfun$apply$52: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodCheck$$anonfun$replaceM$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Names$MethodSig$$anonfun$apply$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Parser$$anon$1$$anonfun$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Parser$$anon$1$$anonfun$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Parser$$anonfun$main$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Parser$$anonfun$parse$1$$anonfun$go$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Parser$$anonfun$parse$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Parser$$anonfun$Parser$$nlines$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Parser$Node$$anonfun$toString$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Scanner$$anonfun$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Scanner$$anonfun$main$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Scanner$$anonfun$maximalmunch$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Scanner$$anonfun$maximalmunch$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> StaticAnal$$anonfun$1$$anonfun$apply$3: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> StaticAnal$$anonfun$1$$anonfun$apply$4: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> StaticAnal$$anonfun$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> StaticAnal$$anonfun$definiteAssignment$1$$anonfun$apply$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> StaticAnal$$anonfun$definiteAssignment$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> StaticAnal$$anonfun$main$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> StaticAnal$$anonfun$reachability$1$$anonfun$apply$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> StaticAnal$$anonfun$reachability$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$3: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$4: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$5: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$6$$anonfun$apply$24: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$6$$anonfun$apply$25: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$6: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$checkAccess$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20$$anonfun$apply$21: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20$$anonfun$apply$22: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$checkConstructorNames$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$15: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$17: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$18: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$19: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$checkForwardReferences$1$1$$anonfun$apply$23: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$checkForwardReferences$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$checkTypes$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disambiguation$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disField$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disField$1$2$$anonfun$apply$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disField$1$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disField$1$3$$anonfun$apply$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disField$1$3: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disField$1$4$$anonfun$apply$3$$anonfun$apply$4: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disField$1$4$$anonfun$apply$3: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disField$1$4: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disField$1$5: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disField$1$6: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disInvoke$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$10: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$11: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$12: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$13: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$14: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$9: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$disLval$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$formalConf$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$main$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$Types$$disMethod$1$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$Types$$disMethod$1$2$$anonfun$apply$5: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$Types$$disMethod$1$2: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$Types$$disMethod$1$3$$anonfun$apply$6: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$Types$$disMethod$1$3: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$Types$$disMethod$1$4$$anonfun$apply$7$$anonfun$apply$8: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$Types$$disMethod$1$4$$anonfun$apply$7: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$Types$$disMethod$1$4: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$Types$$disMethod$1$5: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Types$$anonfun$Types$$disMethod$1$6: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Util$$anonfun$closure$1: apply(Ljava/lang/Object;)
Ast: dfs(n: Ast.AstNode,action: Ast.AstNode => Unit) ===> Util.Memoize: apply(k: Key)
Ast: main(args: Array[String]) ===> Ast: main(args: Array[String])
ca.uwaterloo.scalacg.Library: blob() ===> Ast$$anonfun$3: apply()
ca.uwaterloo.scalacg.Library: blob() ===> Ast$$anonfun$4: apply()
ca.uwaterloo.scalacg.Library: blob() ===> Ast$$anonfun$assertAllLinks$1$$anonfun$apply$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Ast$$anonfun$assertAllLinks$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Ast$$anonfun$assertLinks$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Ast$$anonfun$assertLinks$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Ast$$anonfun$ast_CastExpression$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Ast$$anonfun$ast_ClassDeclaration$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Ast$$anonfun$dfs$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Ast$$anonfun$expandEscapes$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Ast$$anonfun$main$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Ast$$anonfun$main$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Ast$AstNode$$anonfun$linkParents$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Ast$ConstructorDecl$$anonfun$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Ast$MethodDecl$$anonfun$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Ast$RefSpec$$anonfun$typ$1: apply()
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anon$2$$anonfun$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anon$3$$anonfun$8: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anon$3$$anonfun$code$4: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anon$4$$anonfun$code$5: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$7: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$9$$anonfun$apply$21: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$9$$anonfun$apply$22: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$9: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$arrayFrame$lzycompute$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$classFrame$lzycompute$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$1$$anonfun$apply$4: apply()
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$3: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$4: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$5: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$CodeGen$$objectClass$1$1: apply()
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$CodeGen$$stringClass$1$1: apply()
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$15$$anonfun$apply$16: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$15: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$17: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$18: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$19$$anonfun$apply$20: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$19: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$6: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$13: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$10: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$11$$anonfun$apply$12: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$11: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$3: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$4: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$3: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$codeGen$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$constFrame$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$constFrame$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$constrSig$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$main$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$mainClass$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$makeFrame$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$makeFrame$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$methodFrame$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$methodFrame$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$methodSig$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$objectFrame$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$objectFrame$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$$anonfun$objectFrame$3: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$2$$anonfun$apply$3: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$interfaceInvoke$2$$anonfun$3: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$4: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$5: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$6: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$interfaceInvoke$2$$anonfun$code$3: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$subtypeTests$2$$anonfun$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$subtypeTests$2$$anonfun$code$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> CodeGen$subtypeTests$2$$anonfun$code$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> MakeAst$$anonfun$main$1$$anonfun$apply$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> MakeAst$$anonfun$main$1$$anonfun$apply$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> MakeAst$$anonfun$main$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$10: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$12$$anonfun$apply$76: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$12$$anonfun$apply$77: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$12: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$8: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$9: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$32: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$34: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$36: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$37: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$38: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addAbstractObjectMethods$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$39: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$40: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$11: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$43: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$44: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$45: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$46: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addAbstractObjectMethods$1$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addClasses$1$1$$anonfun$apply$5: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$addClasses$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$canonicalNames$1$1$$anonfun$apply$4: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$canonicalNames$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20$$anonfun$apply$21$$anonfun$apply$22: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20$$anonfun$apply$21: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkDemandPackageIsClass$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkHierarchyCycles$1$1$$anonfun$apply$31: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkHierarchyCycles$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$28: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$29$$anonfun$apply$30: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$29: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkInterfaceFields$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17$$anonfun$apply$18$$anonfun$apply$19: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17$$anonfun$apply$18: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkNonExistingPackage$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkPackageClashWithType$1$1$$anonfun$apply$25: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkPackageClashWithType$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkPrefixesOfReferences$1$1$$anonfun$apply$26: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkPrefixesOfReferences$1$1$$anonfun$apply$27: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkPrefixesOfReferences$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkSingleTypeImports$1$1$$anonfun$apply$15$$anonfun$apply$16: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkSingleTypeImports$1$1$$anonfun$apply$15: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$checkSingleTypeImports$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$demandImports$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$demImp$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$demImp$1$2$$anonfun$apply$23: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$demImp$1$2$$anonfun$apply$24: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$demImp$1$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$enclosingBlock$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$enclosingClass$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$environments$1$$anonfun$apply$14: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$environments$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$63: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$64: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$66: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$67: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$68: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$69: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$70: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$71: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$73: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$74: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$75: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$hierarchy$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$interfaces$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$isSubtype$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$main$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$makeEnvs$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$10: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$11: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$12$$anonfun$apply$13: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$12: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$6: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$7: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$8$$anonfun$apply$9: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$8: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$Names$$addMembers$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$Names$$dfs$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$Names$$jlo$1$1: apply()
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$resolveTypes$1$1$$anonfun$7: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$resolveTypes$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$singleImports$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$$anonfun$typeLinking$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$ConstrSig$$anonfun$apply$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$Env$$anonfun$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$Env$$anonfun$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$Env$$anonfun$3: apply()
ca.uwaterloo.scalacg.Library: blob() ===> Names$Env$$anonfun$4$$anonfun$apply$3: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$Env$$anonfun$4: apply()
ca.uwaterloo.scalacg.Library: blob() ===> Names$Env$$anonfun$5: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$Env$$anonfun$lookupClass$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$Env$$anonfun$lookupVar$1: apply()
ca.uwaterloo.scalacg.Library: blob() ===> Names$Env$$anonfun$Names$Env$$tryName$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$Env$$anonfun$resolveClass$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$FieldCheck$$anonfun$declare$3: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$FieldCheck$$anonfun$declare$4: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$FieldCheck$$anonfun$inherit$2$$anonfun$apply$61: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$FieldCheck$$anonfun$inherit$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$allabs$1$$anonfun$apply$47: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$allabs$1$$anonfun$apply$48: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$allabs$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$declare$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$declare$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$49: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$50: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$51: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$inherit$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$nodecl$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$replace$1$$anonfun$apply$53: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$replace$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$56: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$57: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$58: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$59: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$60: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$replace$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$replaceM$1$$anonfun$apply$52: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodCheck$$anonfun$replaceM$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Names$MethodSig$$anonfun$apply$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Parser$$anon$1$$anonfun$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Parser$$anon$1$$anonfun$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Parser$$anonfun$main$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Parser$$anonfun$parse$1$$anonfun$go$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Parser$$anonfun$parse$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Parser$$anonfun$Parser$$nlines$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Parser$Node$$anonfun$toString$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Scanner$$anonfun$1: apply(Ljava/lang/Object;Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Scanner$$anonfun$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Scanner$$anonfun$main$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Scanner$$anonfun$maximalmunch$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Scanner$$anonfun$maximalmunch$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> StaticAnal$$anonfun$1$$anonfun$apply$3: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> StaticAnal$$anonfun$1$$anonfun$apply$4: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> StaticAnal$$anonfun$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> StaticAnal$$anonfun$definiteAssignment$1$$anonfun$apply$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> StaticAnal$$anonfun$definiteAssignment$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> StaticAnal$$anonfun$main$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> StaticAnal$$anonfun$reachability$1$$anonfun$apply$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> StaticAnal$$anonfun$reachability$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$3: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$4: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$5: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$6$$anonfun$apply$24: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$6$$anonfun$apply$25: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$6: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$checkAccess$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20$$anonfun$apply$21: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20$$anonfun$apply$22: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$checkConstructorNames$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$15: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$17: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$18: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$19: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$checkConstructorSuperInvokes$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$checkForwardReferences$1$1$$anonfun$apply$23: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$checkForwardReferences$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$checkTypes$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disambiguation$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disField$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disField$1$2$$anonfun$apply$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disField$1$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disField$1$3$$anonfun$apply$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disField$1$3: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disField$1$4$$anonfun$apply$3$$anonfun$apply$4: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disField$1$4$$anonfun$apply$3: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disField$1$4: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disField$1$5: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disField$1$6: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disInvoke$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disLval$1$1$$anonfun$apply$10: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disLval$1$1$$anonfun$apply$11: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disLval$1$1$$anonfun$apply$12: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disLval$1$1$$anonfun$apply$13: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disLval$1$1$$anonfun$apply$14: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disLval$1$1$$anonfun$apply$9: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$disLval$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$formalConf$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$main$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$stringClass$1$1: apply()
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$Types$$disMethod$1$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$Types$$disMethod$1$2$$anonfun$apply$5: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$Types$$disMethod$1$2: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$Types$$disMethod$1$3$$anonfun$apply$6: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$Types$$disMethod$1$3: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$Types$$disMethod$1$4$$anonfun$apply$7$$anonfun$apply$8: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$Types$$disMethod$1$4$$anonfun$apply$7: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$Types$$disMethod$1$4: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$Types$$disMethod$1$5: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Types$$anonfun$Types$$disMethod$1$6: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Util$$anonfun$closure$1: apply(Ljava/lang/Object;)
ca.uwaterloo.scalacg.Library: blob() ===> Util$Memoize: toString()
CodeGen$$anon$2$$anonfun$1: apply(Ljava/lang/Object;) ===> CodeGen.$anon.$anonfun: apply(x0$5: Ast.AstNode, Int)
CodeGen$$anon$3$$anonfun$8: apply(Ljava/lang/Object;) ===> CodeGen.$anon.$anonfun: apply(x0$8: Ast.AstNode, Int)
CodeGen$$anon$3$$anonfun$code$4: apply(Ljava/lang/Object;) ===> CodeGen.$anon.$anonfun: apply(n: Ast.AstNode)
CodeGen$$anon$4$$anonfun$code$5: apply(Ljava/lang/Object;) ===> CodeGen.$anon.$anonfun: apply(n: Ast.AstNode)
CodeGen$$anon$4: apply(LAst$AstNode;) ===> CodeGen.$anon: apply(ts: Ast.AstNode)
CodeGen$$anon$4: apply(LNames$MethodSig;) ===> CodeGen.$anon: apply(ms: Names.MethodSig)
CodeGen$$anonfun$7: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(x0$7: Ast.MethodDecl, Ast.MethodDecl)
CodeGen$$anonfun$9$$anonfun$apply$21: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun: apply(token: Scanner.Token)
CodeGen$$anonfun$9$$anonfun$apply$22: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
CodeGen$$anonfun$9: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(file: String)
CodeGen$$anonfun$arrayFrame$lzycompute$1$1: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(x$5: Ast.Type)
CodeGen$$anonfun$classFrame$lzycompute$1$1: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(x$4: Ast.ClassDecl)
CodeGen$$anonfun$CodeGen$$classFrameImpl$1$1$$anonfun$apply$4: apply() ===> CodeGen.$anonfun.$anonfun: apply()
CodeGen$$anonfun$CodeGen$$classFrameImpl$1$1: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(n: Ast.AstNode)
CodeGen$$anonfun$CodeGen$$classFrameImpl$1$2: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
CodeGen$$anonfun$CodeGen$$classFrameImpl$1$2: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(method: Ast.MethodDecl)
CodeGen$$anonfun$CodeGen$$classFrameImpl$1$3: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(method: Ast.MethodDecl)
CodeGen$$anonfun$CodeGen$$classFrameImpl$1$4: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
CodeGen$$anonfun$CodeGen$$classFrameImpl$1$4: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(field: Ast.FieldDecl)
CodeGen$$anonfun$CodeGen$$classFrameImpl$1$5: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(field: Ast.FieldDecl)
CodeGen$$anonfun$CodeGen$$objectClass$1$1: apply() ===> CodeGen.$anonfun: apply()
CodeGen$$anonfun$CodeGen$$stringClass$1$1: apply() ===> CodeGen.$anonfun: apply()
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$15$$anonfun$apply$16: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(init: Ast.Expr)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$15: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.$anonfun.$anonfun: apply(memb: Ast.MemberDecl)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$17: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.$anonfun.$anonfun: apply(bl: Ast.Block)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.$anonfun: apply(constr: Ast.ConstructorDecl)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$18: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$18: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.$anonfun: apply(check$ifrefutable$1: String, String)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$19$$anonfun$apply$20: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$19$$anonfun$apply$20: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.$anonfun.$anonfun: apply(c: Char)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$19: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.$anonfun: apply(x$6: String, String)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$6: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$6: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.$anonfun: apply(method: Ast.MethodDecl)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$13: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.$anonfun.$anonfun: apply(bl: Ast.Block)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$10: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$10: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$11$$anonfun$apply$12: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(e: Ast.Expr)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$11: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(fcls: Ast.ClassDecl)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.$anonfun.$anonfun: apply(cu: Ast.CompUnit)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.$anonfun: apply(method: Ast.MethodDecl)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$1: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.generators.$anonfun: apply(p: Ast.Expr)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$2: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.generators.$anonfun: apply(e: Ast.Expr)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$3: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.generators.$anonfun: apply(p: Ast.Expr)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$4: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.generators.$anonfun: apply(p: Ast.Expr)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$1: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.generators.$anonfun: apply(s: Ast.Stmt)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$2: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.generators.$anonfun: apply(in: Ast.Expr)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$3: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun.generators.$anonfun: apply(e: Ast.Expr)
CodeGen$$anonfun$codeGen$1$$anonfun$apply$5: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
CodeGen$$anonfun$codeGen$1: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(cu: Ast.CompUnit)
CodeGen$$anonfun$codeGen$2: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(typ: Product with Serializable with Ast.Type)
CodeGen$$anonfun$constFrame$1: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(x0$1: Ast.AstNode)
CodeGen$$anonfun$constFrame$2: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(x$2: Ast.TypeSpec, String)
CodeGen$$anonfun$constrSig$1: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(x0$4: Ast.TypeSpec, String)
CodeGen$$anonfun$main$1: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(x$7: Ast.AstNode)
CodeGen$$anonfun$mainClass$1$1: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(x$3: Ast.CompUnit)
CodeGen$$anonfun$makeFrame$1: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(ts: Ast.TypeSpec)
CodeGen$$anonfun$makeFrame$2: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(ts: Ast.TypeSpec)
CodeGen$$anonfun$methodFrame$1: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(x0$3: Ast.AstNode)
CodeGen$$anonfun$methodFrame$2: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(x$1: Ast.TypeSpec, String)
CodeGen$$anonfun$methodSig$1: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(x0$2: Ast.TypeSpec, String)
CodeGen$$anonfun$objectFrame$1: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(n: Ast.AstNode)
CodeGen$$anonfun$objectFrame$2: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
CodeGen$$anonfun$objectFrame$2: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(field: Ast.FieldDecl)
CodeGen$$anonfun$objectFrame$3: apply(Ljava/lang/Object;) ===> CodeGen.$anonfun: apply(field: Ast.FieldDecl)
CodeGen$: <clinit>() ===> CodeGen: <init>()
CodeGen$: arrayFrame$lzycompute$1(LAst$Root;Lscala/runtime/ObjectRef;Lscala/runtime/ObjectRef;Lscala/runtime/VolatileObjectRef;Lscala/runtime/VolatileObjectRef;Lscala/runtime/VolatileByteRef;) ===> CodeGen.$anonfun: <init>()
CodeGen$: arrayFrame$lzycompute$1(LAst$Root;Lscala/runtime/ObjectRef;Lscala/runtime/ObjectRef;Lscala/runtime/VolatileObjectRef;Lscala/runtime/VolatileObjectRef;Lscala/runtime/VolatileByteRef;) ===> Util.Memoize: <init>(f: Key => Value)
CodeGen$: classFrame$lzycompute$1(LAst$Root;Lscala/runtime/ObjectRef;Lscala/runtime/VolatileObjectRef;Lscala/runtime/VolatileObjectRef;Lscala/runtime/VolatileByteRef;) ===> CodeGen.$anonfun: <init>()
CodeGen$: classFrame$lzycompute$1(LAst$Root;Lscala/runtime/ObjectRef;Lscala/runtime/VolatileObjectRef;Lscala/runtime/VolatileObjectRef;Lscala/runtime/VolatileByteRef;) ===> Util.Memoize: <init>(f: Key => Value)
CodeGen$: CodeGen$$interfaceInvoke$1$lzycompute(LAst$Root;Lscala/runtime/VolatileObjectRef;) ===> CodeGen.interfaceInvoke: <init>()
CodeGen$: CodeGen$$subtypeTests$1$lzycompute(LAst$Root;Lscala/runtime/VolatileObjectRef;) ===> CodeGen.subtypeTests: <init>()
CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$1: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$1: apply(Ljava/lang/Object;) ===> CodeGen.interfaceInvoke.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$2$$anonfun$apply$3: apply(Ljava/lang/Object;) ===> CodeGen.interfaceInvoke.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl)
CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$2: apply(Ljava/lang/Object;) ===> CodeGen.interfaceInvoke.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
CodeGen$interfaceInvoke$2$$anonfun$3: apply(Ljava/lang/Object;) ===> CodeGen.interfaceInvoke.$anonfun: apply(cu: Ast.CompUnit)
CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$4: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$4: apply(Ljava/lang/Object;) ===> CodeGen.interfaceInvoke.$anonfun.$anonfun: apply(method: Ast.MethodDecl)
CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$5: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$5: apply(Ljava/lang/Object;) ===> CodeGen.interfaceInvoke.$anonfun.$anonfun: apply(method: Ast.MethodDecl)
CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$6: apply(Ljava/lang/Object;) ===> CodeGen.interfaceInvoke.$anonfun.$anonfun: apply(method: Ast.MethodDecl)
CodeGen$interfaceInvoke$2$$anonfun$code$3: apply(Ljava/lang/Object;) ===> CodeGen.interfaceInvoke.$anonfun: apply(sig: Names.MethodSig)
CodeGen$subtypeTests$2$$anonfun$2: apply(Ljava/lang/Object;) ===> CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode)
CodeGen$subtypeTests$2$$anonfun$code$1: apply(Ljava/lang/Object;) ===> CodeGen.subtypeTests.$anonfun: apply(sup: Ast.Type)
CodeGen$subtypeTests$2$$anonfun$code$2: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
CodeGen$subtypeTests$2$$anonfun$code$2: apply(Ljava/lang/Object;) ===> CodeGen.subtypeTests.$anonfun: apply(w: Int)
CodeGen.$anon.$anonfun: apply(n: Ast.AstNode) ===> Ast.ArrayType: equals(x$1: Any)
CodeGen.$anon.$anonfun: apply(n: Ast.AstNode) ===> Ast.ImportClass: equals(x$1: Any)
CodeGen.$anon.$anonfun: apply(n: Ast.AstNode) ===> Ast.ImportStar: equals(x$1: Any)
CodeGen.$anon.$anonfun: apply(n: Ast.AstNode) ===> Ast.Name: equals(x$1: Any)
CodeGen.$anon.$anonfun: apply(n: Ast.AstNode) ===> Ast.RefType: equals(x$1: Any)
CodeGen.$anon.$anonfun: apply(n: Ast.AstNode) ===> Names.ConstrSig: equals(x$1: Any)
CodeGen.$anon.$anonfun: apply(n: Ast.AstNode) ===> Names.MethodSig: equals(x$1: Any)
CodeGen.$anon.$anonfun: apply(n: Ast.AstNode) ===> Parser.Leaf: equals(x$1: Any)
CodeGen.$anon.$anonfun: apply(n: Ast.AstNode) ===> Parser.Node: equals(x$1: Any)
CodeGen.$anon.$anonfun: apply(n: Ast.AstNode) ===> Parser.Production: equals(x$1: Any)
CodeGen.$anon.$anonfun: apply(n: Ast.AstNode) ===> Parser.Reduce: equals(x$1: Any)
CodeGen.$anon.$anonfun: apply(n: Ast.AstNode) ===> Parser.Shift: equals(x$1: Any)
CodeGen.$anon.$anonfun: apply(n: Ast.AstNode) ===> Scanner.Token: equals(x$1: Any)
CodeGen.$anon.$anonfun: apply(x0$8: Ast.AstNode, Int) ===> CodeGen: interfaceInvoke()
CodeGen.$anon.$anonfun: apply(x0$8: Ast.AstNode, Int) ===> CodeGen: subtypeTests()
CodeGen.$anon: apply(ms: Names.MethodSig) ===> CodeGen: interfaceInvoke()
CodeGen.$anon: apply(ms: Names.MethodSig) ===> CodeGen: subtypeTests()
CodeGen.$anon: code(fos: java.io.PrintStream) ===> CodeGen: interfaceInvoke()
CodeGen.$anon: code(fos: java.io.PrintStream) ===> CodeGen: subtypeTests()
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(e: Ast.Expr) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$11: CodeGen$$anonfun$$anonfun$$anonfun$$anonfun$$anonfun$$anonfun$$$outer()
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(e: Ast.Expr) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9: CodeGen$$anonfun$$anonfun$$anonfun$$anonfun$$anonfun$$$outer()
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl) ===> Ast.ArrayType: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl) ===> Ast.ImportClass: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl) ===> Ast.ImportStar: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl) ===> Ast.Name: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl) ===> Ast.RefType: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl) ===> CodeGen$$anon$4: apply(LAst$AstNode;)
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9: CodeGen$$anonfun$$anonfun$$anonfun$$anonfun$$anonfun$$$outer()
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8: CodeGen$$anonfun$$anonfun$$anonfun$$anonfun$$$outer()
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7: CodeGen$$anonfun$$anonfun$$anonfun$$$outer()
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5: CodeGen$$anonfun$$anonfun$$$outer()
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl) ===> Names.ConstrSig: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl) ===> Names.MethodSig: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl) ===> Parser.Leaf: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl) ===> Parser.Node: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl) ===> Parser.Production: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl) ===> Parser.Reduce: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl) ===> Parser.Shift: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(f: Ast.FieldDecl) ===> Scanner.Token: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(init: Ast.Expr) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$15: CodeGen$$anonfun$$anonfun$$anonfun$$anonfun$$$outer()
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun.$anonfun: apply(init: Ast.Expr) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14: CodeGen$$anonfun$$anonfun$$anonfun$$$outer()
CodeGen.$anonfun.$anonfun.$anonfun.$anonfun: apply(bl: Ast.Block) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14: CodeGen$$anonfun$$anonfun$$anonfun$$$outer()
CodeGen.$anonfun.$anonfun.$anonfun: apply(method: Ast.MethodDecl) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5: CodeGen$$anonfun$$anonfun$$$outer()
CodeGen.$anonfun.$anonfun.generators: fixType(t: Ast.Type) ===> Ast.ArrayType: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: fixType(t: Ast.Type) ===> Ast.ImportClass: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: fixType(t: Ast.Type) ===> Ast.ImportStar: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: fixType(t: Ast.Type) ===> Ast.Name: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: fixType(t: Ast.Type) ===> Ast.RefType: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: fixType(t: Ast.Type) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1: CodeGen$$anonfun$$anonfun$generators$$$outer()
CodeGen.$anonfun.$anonfun.generators: fixType(t: Ast.Type) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5: CodeGen$$anonfun$$anonfun$$$outer()
CodeGen.$anonfun.$anonfun.generators: fixType(t: Ast.Type) ===> Names.ConstrSig: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: fixType(t: Ast.Type) ===> Names.MethodSig: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: fixType(t: Ast.Type) ===> Parser.Leaf: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: fixType(t: Ast.Type) ===> Parser.Node: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: fixType(t: Ast.Type) ===> Parser.Production: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: fixType(t: Ast.Type) ===> Parser.Reduce: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: fixType(t: Ast.Type) ===> Parser.Shift: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: fixType(t: Ast.Type) ===> Scanner.Token: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genAddr(e: Ast.Expr) ===> Ast.ArrayType: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genAddr(e: Ast.Expr) ===> Ast.ImportClass: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genAddr(e: Ast.Expr) ===> Ast.ImportStar: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genAddr(e: Ast.Expr) ===> Ast.Name: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genAddr(e: Ast.Expr) ===> Ast.RefType: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genAddr(e: Ast.Expr) ===> CodeGen$$anon$4: apply(LAst$AstNode;)
CodeGen.$anonfun.$anonfun.generators: genAddr(e: Ast.Expr) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1: CodeGen$$anonfun$$anonfun$generators$$$outer()
CodeGen.$anonfun.$anonfun.generators: genAddr(e: Ast.Expr) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5: CodeGen$$anonfun$$anonfun$$$outer()
CodeGen.$anonfun.$anonfun.generators: genAddr(e: Ast.Expr) ===> Names.ConstrSig: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genAddr(e: Ast.Expr) ===> Names.MethodSig: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genAddr(e: Ast.Expr) ===> Parser.Leaf: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genAddr(e: Ast.Expr) ===> Parser.Node: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genAddr(e: Ast.Expr) ===> Parser.Production: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genAddr(e: Ast.Expr) ===> Parser.Reduce: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genAddr(e: Ast.Expr) ===> Parser.Shift: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genAddr(e: Ast.Expr) ===> Scanner.Token: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Ast$ArraySpec: typ()
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Ast$BooleanSpec: typ()
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Ast$ByteSpec: typ()
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Ast$CharSpec: typ()
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Ast$IntSpec: typ()
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Ast$RefSpec: typ()
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Ast$ShortSpec: typ()
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Ast$VoidSpec: typ()
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Ast.ArrayType: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Ast.ImportClass: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Ast.ImportStar: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Ast.Name: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Ast.RefType: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> CodeGen$$anon$4: apply(LAst$AstNode;)
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> CodeGen$$anon$4: apply(LNames$MethodSig;)
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1: CodeGen$$anonfun$$anonfun$generators$$$outer()
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5: CodeGen$$anonfun$$anonfun$$$outer()
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> CodeGen: subtypeTests()
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Names.ConstrSig: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Names.MethodSig: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Parser.Leaf: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Parser.Node: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Parser.Production: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Parser.Reduce: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Parser.Shift: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genExpr(e: Ast.Expr) ===> Scanner.Token: equals(x$1: Any)
CodeGen.$anonfun.$anonfun.generators: genStmt(s: Ast.Stmt) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1: CodeGen$$anonfun$$anonfun$generators$$$outer()
CodeGen.$anonfun.$anonfun.generators: genStmt(s: Ast.Stmt) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5: CodeGen$$anonfun$$anonfun$$$outer()
CodeGen.$anonfun.$anonfun.generators: prepareedx() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1: CodeGen$$anonfun$$anonfun$generators$$$outer()
CodeGen.$anonfun.$anonfun.generators: prepareedx() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5: CodeGen$$anonfun$$anonfun$$$outer()
CodeGen.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.ArrayType: equals(x$1: Any)
CodeGen.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.ImportClass: equals(x$1: Any)
CodeGen.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.ImportStar: equals(x$1: Any)
CodeGen.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.Name: equals(x$1: Any)
CodeGen.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.RefType: equals(x$1: Any)
CodeGen.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Names.ConstrSig: equals(x$1: Any)
CodeGen.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Names.MethodSig: equals(x$1: Any)
CodeGen.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Leaf: equals(x$1: Any)
CodeGen.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Node: equals(x$1: Any)
CodeGen.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Production: equals(x$1: Any)
CodeGen.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Reduce: equals(x$1: Any)
CodeGen.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Shift: equals(x$1: Any)
CodeGen.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Scanner.Token: equals(x$1: Any)
CodeGen.$anonfun: apply(x0$2: Ast.TypeSpec, String) ===> Ast$ArraySpec: typ()
CodeGen.$anonfun: apply(x0$2: Ast.TypeSpec, String) ===> Ast$BooleanSpec: typ()
CodeGen.$anonfun: apply(x0$2: Ast.TypeSpec, String) ===> Ast$ByteSpec: typ()
CodeGen.$anonfun: apply(x0$2: Ast.TypeSpec, String) ===> Ast$CharSpec: typ()
CodeGen.$anonfun: apply(x0$2: Ast.TypeSpec, String) ===> Ast$IntSpec: typ()
CodeGen.$anonfun: apply(x0$2: Ast.TypeSpec, String) ===> Ast$RefSpec: typ()
CodeGen.$anonfun: apply(x0$2: Ast.TypeSpec, String) ===> Ast$ShortSpec: typ()
CodeGen.$anonfun: apply(x0$2: Ast.TypeSpec, String) ===> Ast$VoidSpec: typ()
CodeGen.$anonfun: apply(x0$4: Ast.TypeSpec, String) ===> Ast$ArraySpec: typ()
CodeGen.$anonfun: apply(x0$4: Ast.TypeSpec, String) ===> Ast$BooleanSpec: typ()
CodeGen.$anonfun: apply(x0$4: Ast.TypeSpec, String) ===> Ast$ByteSpec: typ()
CodeGen.$anonfun: apply(x0$4: Ast.TypeSpec, String) ===> Ast$CharSpec: typ()
CodeGen.$anonfun: apply(x0$4: Ast.TypeSpec, String) ===> Ast$IntSpec: typ()
CodeGen.$anonfun: apply(x0$4: Ast.TypeSpec, String) ===> Ast$RefSpec: typ()
CodeGen.$anonfun: apply(x0$4: Ast.TypeSpec, String) ===> Ast$ShortSpec: typ()
CodeGen.$anonfun: apply(x0$4: Ast.TypeSpec, String) ===> Ast$VoidSpec: typ()
CodeGen.interfaceInvoke.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$2: CodeGen$interfaceInvoke$$anonfun$$anonfun$$$outer()
CodeGen.interfaceInvoke.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> CodeGen$interfaceInvoke$2$$anonfun$3: CodeGen$interfaceInvoke$$anonfun$$$outer()
CodeGen.interfaceInvoke.$anonfun.$anonfun: apply(method: Ast.MethodDecl) ===> Ast.ArrayType: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun.$anonfun: apply(method: Ast.MethodDecl) ===> Ast.ImportClass: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun.$anonfun: apply(method: Ast.MethodDecl) ===> Ast.ImportStar: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun.$anonfun: apply(method: Ast.MethodDecl) ===> Ast.Name: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun.$anonfun: apply(method: Ast.MethodDecl) ===> Ast.RefType: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun.$anonfun: apply(method: Ast.MethodDecl) ===> Names.ConstrSig: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun.$anonfun: apply(method: Ast.MethodDecl) ===> Names.MethodSig: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun.$anonfun: apply(method: Ast.MethodDecl) ===> Parser.Leaf: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun.$anonfun: apply(method: Ast.MethodDecl) ===> Parser.Node: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun.$anonfun: apply(method: Ast.MethodDecl) ===> Parser.Production: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun.$anonfun: apply(method: Ast.MethodDecl) ===> Parser.Reduce: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun.$anonfun: apply(method: Ast.MethodDecl) ===> Parser.Shift: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun.$anonfun: apply(method: Ast.MethodDecl) ===> Scanner.Token: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun: apply(sig: Names.MethodSig) ===> Ast.ArrayType: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun: apply(sig: Names.MethodSig) ===> Ast.ImportClass: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun: apply(sig: Names.MethodSig) ===> Ast.ImportStar: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun: apply(sig: Names.MethodSig) ===> Ast.Name: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun: apply(sig: Names.MethodSig) ===> Ast.RefType: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun: apply(sig: Names.MethodSig) ===> Names.ConstrSig: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun: apply(sig: Names.MethodSig) ===> Names.MethodSig: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun: apply(sig: Names.MethodSig) ===> Parser.Leaf: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun: apply(sig: Names.MethodSig) ===> Parser.Node: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun: apply(sig: Names.MethodSig) ===> Parser.Production: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun: apply(sig: Names.MethodSig) ===> Parser.Reduce: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun: apply(sig: Names.MethodSig) ===> Parser.Shift: equals(x$1: Any)
CodeGen.interfaceInvoke.$anonfun: apply(sig: Names.MethodSig) ===> Scanner.Token: equals(x$1: Any)
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Ast$ArraySpec: typ()
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Ast$BooleanSpec: typ()
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Ast$ByteSpec: typ()
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Ast$CharSpec: typ()
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Ast$IntSpec: typ()
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Ast$RefSpec: typ()
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Ast$ShortSpec: typ()
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Ast$VoidSpec: typ()
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Ast.ArrayType: equals(x$1: Any)
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Ast.ImportClass: equals(x$1: Any)
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Ast.ImportStar: equals(x$1: Any)
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Ast.Name: equals(x$1: Any)
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Ast.RefType: equals(x$1: Any)
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Names.ConstrSig: equals(x$1: Any)
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Names.MethodSig: equals(x$1: Any)
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Parser.Leaf: equals(x$1: Any)
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Parser.Node: equals(x$1: Any)
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Parser.Production: equals(x$1: Any)
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Parser.Reduce: equals(x$1: Any)
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Parser.Shift: equals(x$1: Any)
CodeGen.subtypeTests.$anonfun: apply(x0$6: Ast.AstNode) ===> Scanner.Token: equals(x$1: Any)
CodeGen: arrayFrame() ===> CodeGen$: arrayFrame$lzycompute$1(LAst$Root;Lscala/runtime/ObjectRef;Lscala/runtime/ObjectRef;Lscala/runtime/VolatileObjectRef;Lscala/runtime/VolatileObjectRef;Lscala/runtime/VolatileByteRef;)
CodeGen: classFrame() ===> CodeGen$: classFrame$lzycompute$1(LAst$Root;Lscala/runtime/ObjectRef;Lscala/runtime/VolatileObjectRef;Lscala/runtime/VolatileObjectRef;Lscala/runtime/VolatileByteRef;)
CodeGen: interfaceInvoke() ===> CodeGen$: CodeGen$$interfaceInvoke$1$lzycompute(LAst$Root;Lscala/runtime/VolatileObjectRef;)
CodeGen: isMain(cls: Ast.ClassDecl,m: Ast.MethodDecl) ===> Ast.ArrayType: equals(x$1: Any)
CodeGen: isMain(cls: Ast.ClassDecl,m: Ast.MethodDecl) ===> Ast.ImportClass: equals(x$1: Any)
CodeGen: isMain(cls: Ast.ClassDecl,m: Ast.MethodDecl) ===> Ast.ImportStar: equals(x$1: Any)
CodeGen: isMain(cls: Ast.ClassDecl,m: Ast.MethodDecl) ===> Ast.Name: equals(x$1: Any)
CodeGen: isMain(cls: Ast.ClassDecl,m: Ast.MethodDecl) ===> Ast.RefType: equals(x$1: Any)
CodeGen: isMain(cls: Ast.ClassDecl,m: Ast.MethodDecl) ===> Names.ConstrSig: equals(x$1: Any)
CodeGen: isMain(cls: Ast.ClassDecl,m: Ast.MethodDecl) ===> Names.MethodSig: equals(x$1: Any)
CodeGen: isMain(cls: Ast.ClassDecl,m: Ast.MethodDecl) ===> Parser.Leaf: equals(x$1: Any)
CodeGen: isMain(cls: Ast.ClassDecl,m: Ast.MethodDecl) ===> Parser.Node: equals(x$1: Any)
CodeGen: isMain(cls: Ast.ClassDecl,m: Ast.MethodDecl) ===> Parser.Production: equals(x$1: Any)
CodeGen: isMain(cls: Ast.ClassDecl,m: Ast.MethodDecl) ===> Parser.Reduce: equals(x$1: Any)
CodeGen: isMain(cls: Ast.ClassDecl,m: Ast.MethodDecl) ===> Parser.Shift: equals(x$1: Any)
CodeGen: isMain(cls: Ast.ClassDecl,m: Ast.MethodDecl) ===> Scanner.Token: equals(x$1: Any)
CodeGen: main(args: Array[String]) ===> CodeGen: main(args: Array[String])
CodeGen: subtypeTests() ===> CodeGen$: CodeGen$$subtypeTests$1$lzycompute(LAst$Root;Lscala/runtime/VolatileObjectRef;)
CodeGen: typeSig(typ: Ast.Type) ===> Ast.ArrayType: equals(x$1: Any)
CodeGen: typeSig(typ: Ast.Type) ===> Ast.ImportClass: equals(x$1: Any)
CodeGen: typeSig(typ: Ast.Type) ===> Ast.ImportStar: equals(x$1: Any)
CodeGen: typeSig(typ: Ast.Type) ===> Ast.Name: equals(x$1: Any)
CodeGen: typeSig(typ: Ast.Type) ===> Ast.RefType: equals(x$1: Any)
CodeGen: typeSig(typ: Ast.Type) ===> Names.ConstrSig: equals(x$1: Any)
CodeGen: typeSig(typ: Ast.Type) ===> Names.MethodSig: equals(x$1: Any)
CodeGen: typeSig(typ: Ast.Type) ===> Parser.Leaf: equals(x$1: Any)
CodeGen: typeSig(typ: Ast.Type) ===> Parser.Node: equals(x$1: Any)
CodeGen: typeSig(typ: Ast.Type) ===> Parser.Production: equals(x$1: Any)
CodeGen: typeSig(typ: Ast.Type) ===> Parser.Reduce: equals(x$1: Any)
CodeGen: typeSig(typ: Ast.Type) ===> Parser.Shift: equals(x$1: Any)
CodeGen: typeSig(typ: Ast.Type) ===> Scanner.Token: equals(x$1: Any)
MakeAst$$anonfun$main$1$$anonfun$apply$1: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
MakeAst$$anonfun$main$1$$anonfun$apply$1: apply(Ljava/lang/Object;) ===> MakeAst.$anonfun.$anonfun: apply(prod: Parser.Production)
MakeAst$$anonfun$main$1$$anonfun$apply$2: apply(Ljava/lang/Object;) ===> MakeAst.$anonfun.$anonfun: apply(prod: Parser.Production)
MakeAst$$anonfun$main$1: apply(Ljava/lang/Object;) ===> MakeAst.$anonfun: apply(nt: String)
MakeAst$: <clinit>() ===> MakeAst: <init>()
MakeAst.$anonfun.$anonfun: apply(prod: Parser.Production) ===> Ast.ArrayType: equals(x$1: Any)
MakeAst.$anonfun.$anonfun: apply(prod: Parser.Production) ===> Ast.ImportClass: equals(x$1: Any)
MakeAst.$anonfun.$anonfun: apply(prod: Parser.Production) ===> Ast.ImportStar: equals(x$1: Any)
MakeAst.$anonfun.$anonfun: apply(prod: Parser.Production) ===> Ast.Name: equals(x$1: Any)
MakeAst.$anonfun.$anonfun: apply(prod: Parser.Production) ===> Ast.RefType: equals(x$1: Any)
MakeAst.$anonfun.$anonfun: apply(prod: Parser.Production) ===> Names.ConstrSig: equals(x$1: Any)
MakeAst.$anonfun.$anonfun: apply(prod: Parser.Production) ===> Names.MethodSig: equals(x$1: Any)
MakeAst.$anonfun.$anonfun: apply(prod: Parser.Production) ===> Parser.Leaf: equals(x$1: Any)
MakeAst.$anonfun.$anonfun: apply(prod: Parser.Production) ===> Parser.Node: equals(x$1: Any)
MakeAst.$anonfun.$anonfun: apply(prod: Parser.Production) ===> Parser.Production: equals(x$1: Any)
MakeAst.$anonfun.$anonfun: apply(prod: Parser.Production) ===> Parser.Reduce: equals(x$1: Any)
MakeAst.$anonfun.$anonfun: apply(prod: Parser.Production) ===> Parser.Shift: equals(x$1: Any)
MakeAst.$anonfun.$anonfun: apply(prod: Parser.Production) ===> Scanner.Token: equals(x$1: Any)
MakeAst: main(args: Array[String]) ===> MakeAst: main(args: Array[String])
Names$$anonfun$10: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(n: Ast.Name)
Names$$anonfun$12$$anonfun$apply$76: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(token: Scanner.Token)
Names$$anonfun$12$$anonfun$apply$77: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Names$$anonfun$12: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(file: String)
Names$$anonfun$8: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(x$22: Ast.CompUnit)
Names$$anonfun$9: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(cu: Ast.CompUnit)
Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$32: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$32: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$34: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$34: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$36: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$36: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl)
Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$37: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$37: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl)
Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$38: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl)
Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Names$$anonfun$addAbstractObjectMethods$1$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(cu: Ast.CompUnit)
Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$39: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$39: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$40: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$40: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$11: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x0$1: Ast.TypeSpec, String)
Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$43: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$43: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$44: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$44: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$45: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$46: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$46: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl)
Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Names$$anonfun$addAbstractObjectMethods$1$2: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(cu: Ast.CompUnit)
Names$$anonfun$addClasses$1$1$$anonfun$apply$5: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Names$$anonfun$addClasses$1$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(cu: Ast.CompUnit)
Names$$anonfun$canonicalNames$1$1$$anonfun$apply$4: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Names$$anonfun$canonicalNames$1$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(cu: Ast.CompUnit)
Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20$$anonfun$apply$21$$anonfun$apply$22: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20$$anonfun$apply$21$$anonfun$apply$22: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20$$anonfun$apply$21: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20$$anonfun$apply$21: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun: apply(x$20: Ast.CompUnit)
Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(imp: Ast.Name)
Names$$anonfun$checkDemandPackageIsClass$1$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(cu: Ast.CompUnit)
Names$$anonfun$checkHierarchyCycles$1$1$$anonfun$apply$31: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Names$$anonfun$checkHierarchyCycles$1$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(cu: Ast.CompUnit)
Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$28: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$28: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$29$$anonfun$apply$30: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun: apply(memb: Ast.MemberDecl)
Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$29: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Names$$anonfun$checkInterfaceFields$1$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(cu: Ast.CompUnit)
Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17$$anonfun$apply$18$$anonfun$apply$19: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17$$anonfun$apply$18$$anonfun$apply$19: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x$19: List[String])
Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17$$anonfun$apply$18: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17$$anonfun$apply$18: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun: apply(cu: Ast.CompUnit)
Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(imp: Ast.Name)
Names$$anonfun$checkNonExistingPackage$1$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(cu: Ast.CompUnit)
Names$$anonfun$checkPackageClashWithType$1$1$$anonfun$apply$25: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(prefix: List[String])
Names$$anonfun$checkPackageClashWithType$1$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(name: Ast.Name)
Names$$anonfun$checkPrefixesOfReferences$1$1$$anonfun$apply$26: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$checkPrefixesOfReferences$1$1$$anonfun$apply$26: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(prefix: List[String])
Names$$anonfun$checkPrefixesOfReferences$1$1$$anonfun$apply$27: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(prefix: List[String])
Names$$anonfun$checkPrefixesOfReferences$1$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(x$25: Ast.AstNode)
Names$$anonfun$checkSingleTypeImports$1$1$$anonfun$apply$15$$anonfun$apply$16: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun: apply(name: Ast.Name)
Names$$anonfun$checkSingleTypeImports$1$1$$anonfun$apply$15: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Names$$anonfun$checkSingleTypeImports$1$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(cu: Ast.CompUnit)
Names$$anonfun$demandImports$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(x$18: Ast.Import)
Names$$anonfun$demImp$1$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(cu: Ast.CompUnit)
Names$$anonfun$demImp$1$2$$anonfun$apply$23: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(x$21: Ast.CompUnit)
Names$$anonfun$demImp$1$2$$anonfun$apply$24: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$demImp$1$2$$anonfun$apply$24: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Names$$anonfun$demImp$1$2: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$demImp$1$2: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(impName: Ast.Name)
Names$$anonfun$enclosingBlock$1: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$enclosingBlock$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(a: Ast.AstNode)
Names$$anonfun$enclosingClass$1: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$enclosingClass$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(x$9: Ast.AstNode)
Names$$anonfun$environments$1$$anonfun$apply$14: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Names$$anonfun$environments$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(cu: Ast.CompUnit)
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$63: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$63: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun: apply(x$36: Ast.TypeSpec)
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$64: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun: apply(i: Ast.ClassDecl)
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$66: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$66: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$67: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$67: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$68: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl)
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$69: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$69: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl)
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$70: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$70: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun: apply(check$ifrefutable$3: Ast.MethodDecl, Ast.MethodDecl)
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$71: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl)
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$73: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$73: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$74: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$74: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$75: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl)
Names$$anonfun$hierarchy$1$$anonfun$apply$62: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Names$$anonfun$hierarchy$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(cu: Ast.CompUnit)
Names$$anonfun$interfaces$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(i: Ast.TypeSpec)
Names$$anonfun$isSubtype$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(x$30: Ast.ClassDecl)
Names$$anonfun$main$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(x$38: Ast.AstNode)
Names$$anonfun$makeEnvs$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(ch: Ast.AstNode)
Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$10: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$10: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(check$ifrefutable$2: Ast.TypeSpec, String)
Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$11: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(x$15: Ast.TypeSpec, String)
Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$12$$anonfun$apply$13: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun: apply(x$16: Ast.AstNode)
Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$12: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(body: Ast.Block)
Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$6: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$6: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(check$ifrefutable$1: Ast.TypeSpec, String)
Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$7: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(x$13: Ast.TypeSpec, String)
Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$8$$anonfun$apply$9: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun.$anonfun: apply(x$14: Ast.AstNode)
Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$8: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(body: Ast.Block)
Names$$anonfun$Names$$addMembers$1$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(member: Ast.MemberDecl)
Names$$anonfun$Names$$dfs$1$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(i: Ast.ClassDecl)
Names$$anonfun$Names$$jlo$1$1: apply() ===> Names.$anonfun: apply()
Names$$anonfun$resolveTypes$1$1$$anonfun$7: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$$anonfun$resolveTypes$1$1$$anonfun$7: apply(Ljava/lang/Object;) ===> Names.$anonfun.$anonfun: apply(x$12: Ast.AstNode)
Names$$anonfun$resolveTypes$1$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(x$11: Ast.AstNode)
Names$$anonfun$singleImports$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(x$17: Ast.Import)
Names$$anonfun$typeLinking$1: apply(Ljava/lang/Object;) ===> Names.$anonfun: apply(x$27: Ast.AstNode)
Names$: <clinit>() ===> Names: <init>()
Names$ConstrSig$$anonfun$apply$2: apply(Ljava/lang/Object;) ===> Names.ConstrSig.$anonfun: apply(x0$3: Ast.TypeSpec, String)
Names$ConstrSig$: <clinit>() ===> Names.ConstrSig: <init>()
Names$Env$$anonfun$1: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$Env$$anonfun$1: apply(Ljava/lang/Object;) ===> Names.Env.$anonfun: apply(x$3: Ast.AstNode)
Names$Env$$anonfun$2: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$Env$$anonfun$2: apply(Ljava/lang/Object;) ===> Names.Env.$anonfun: apply(full: Ast.Name)
Names$Env$$anonfun$3: apply() ===> Names.Env.$anonfun: apply()
Names$Env$$anonfun$4$$anonfun$apply$3: apply(Ljava/lang/Object;) ===> Names.Env.$anonfun.$anonfun: apply(pkg: Ast.Name)
Names$Env$$anonfun$4: apply() ===> Names.Env.$anonfun: apply()
Names$Env$$anonfun$5: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$Env$$anonfun$5: apply(Ljava/lang/Object;) ===> Names.Env.$anonfun: apply(x$8: Ast.FieldDecl)
Names$Env$$anonfun$lookupClass$1: apply(Ljava/lang/Object;) ===> Names.Env.$anonfun: apply(x$2: Ast.Name)
Names$Env$$anonfun$lookupVar$1: apply() ===> Names.Env.$anonfun: apply()
Names$Env$$anonfun$Names$Env$$tryName$1$1: apply(Ljava/lang/Object;) ===> Names.Env.$anonfun: apply(x$4: Ast.Name)
Names$Env$$anonfun$resolveClass$1: apply(Ljava/lang/Object;) ===> Names.Env.$anonfun: apply(prefix: List[String])
Names$Env: classes$lzycompute() ===> Ast.AstNode: env()
Names$Env: classes$lzycompute() ===> Ast.AstNode: parent()
Names$Env: classes$lzycompute() ===> ca.uwaterloo.scalacg.Library: blob()
Names$Env: classes$lzycompute() ===> Names.Env: classes()
Names$Env: classes$lzycompute() ===> Names.Env: node()
Names$Env: constrs$lzycompute() ===> Ast.AstNode: env()
Names$Env: constrs$lzycompute() ===> Ast.AstNode: parent()
Names$Env: constrs$lzycompute() ===> ca.uwaterloo.scalacg.Library: blob()
Names$Env: constrs$lzycompute() ===> Names.Env: constrs()
Names$Env: constrs$lzycompute() ===> Names.Env: node()
Names$Env: fields$lzycompute() ===> Ast.AstNode: env()
Names$Env: fields$lzycompute() ===> Ast.AstNode: parent()
Names$Env: fields$lzycompute() ===> ca.uwaterloo.scalacg.Library: blob()
Names$Env: fields$lzycompute() ===> Names.Env: fields()
Names$Env: fields$lzycompute() ===> Names.Env: node()
Names$Env: methods$lzycompute() ===> Ast.AstNode: env()
Names$Env: methods$lzycompute() ===> Ast.AstNode: parent()
Names$Env: methods$lzycompute() ===> ca.uwaterloo.scalacg.Library: blob()
Names$Env: methods$lzycompute() ===> Names.Env: methods()
Names$Env: methods$lzycompute() ===> Names.Env: node()
Names$FieldCheck$$anonfun$declare$3: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$FieldCheck$$anonfun$declare$3: apply(Ljava/lang/Object;) ===> Names.FieldCheck.$anonfun: apply(x$34: Ast.MemberDecl)
Names$FieldCheck$$anonfun$declare$4: apply(Ljava/lang/Object;) ===> Names.FieldCheck.$anonfun: apply(x$35: Ast.MemberDecl)
Names$FieldCheck$$anonfun$inherit$2$$anonfun$apply$61: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$FieldCheck$$anonfun$inherit$2$$anonfun$apply$61: apply(Ljava/lang/Object;) ===> Names.FieldCheck.$anonfun.$anonfun: apply(fp: Ast.FieldDecl)
Names$FieldCheck$$anonfun$inherit$2: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$FieldCheck$$anonfun$inherit$2: apply(Ljava/lang/Object;) ===> Names.FieldCheck.$anonfun: apply(f: Ast.FieldDecl)
Names$FieldCheck$: <clinit>() ===> Names.FieldCheck: <init>()
Names$MethodCheck$$anonfun$allabs$1$$anonfun$apply$47: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$MethodCheck$$anonfun$allabs$1$$anonfun$apply$47: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$MethodCheck$$anonfun$allabs$1$$anonfun$apply$48: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$MethodCheck$$anonfun$allabs$1: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun: apply(s: Ast.ClassDecl)
Names$MethodCheck$$anonfun$declare$1: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$MethodCheck$$anonfun$declare$1: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun: apply(x$31: Ast.MemberDecl)
Names$MethodCheck$$anonfun$declare$2: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun: apply(x$32: Ast.MemberDecl)
Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$49: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$49: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun.$anonfun: apply(m: Ast.MethodDecl)
Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$50: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$50: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun.$anonfun: apply(m: Ast.MethodDecl)
Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$51: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun.$anonfun: apply(m: Ast.MethodDecl)
Names$MethodCheck$$anonfun$inherit$1: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun: apply(s: Ast.ClassDecl)
Names$MethodCheck$$anonfun$nodecl$1: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$MethodCheck$$anonfun$nodecl$1: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun: apply(mp: Ast.MethodDecl)
Names$MethodCheck$$anonfun$replace$1$$anonfun$apply$53: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$MethodCheck$$anonfun$replace$1: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun: apply(m: Ast.MethodDecl)
Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$56: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$56: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$57: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$57: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$58: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$58: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$59: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$59: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$60: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl)
Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun.$anonfun: apply(sp: Ast.ClassDecl)
Names$MethodCheck$$anonfun$replace$2: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun: apply(s: Ast.ClassDecl)
Names$MethodCheck$$anonfun$replaceM$1$$anonfun$apply$52: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Names$MethodCheck$$anonfun$replaceM$1$$anonfun$apply$52: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun.$anonfun: apply(mp: Ast.MethodDecl)
Names$MethodCheck$$anonfun$replaceM$1: apply(Ljava/lang/Object;) ===> Names.MethodCheck.$anonfun: apply(x$33: Ast.ClassDecl)
Names$MethodCheck$: <clinit>() ===> Names.MethodCheck: <init>()
Names$MethodSig$$anonfun$apply$1: apply(Ljava/lang/Object;) ===> Names.MethodSig.$anonfun: apply(x0$2: Ast.TypeSpec, String)
Names$MethodSig$: <clinit>() ===> Names.MethodSig: <init>()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.ArrayType: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.ImportClass: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.ImportStar: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.Name: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.RefType: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Names.ConstrSig: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Names.MethodSig: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Leaf: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Node: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Production: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Reduce: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Shift: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Scanner.Token: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast.ArrayType: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast.ImportClass: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast.ImportStar: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast.Name: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast.RefType: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Names.ConstrSig: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Names.MethodSig: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Parser.Leaf: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Parser.Node: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Parser.Production: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Parser.Reduce: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Parser.Shift: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Scanner.Token: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast$ArraySpec: typ()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast$BooleanSpec: typ()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast$ByteSpec: typ()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast$CharSpec: typ()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast$IntSpec: typ()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast$RefSpec: typ()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast$ShortSpec: typ()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast$VoidSpec: typ()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.ArrayType: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.ImportClass: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.ImportStar: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.Name: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.RefType: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Names.ConstrSig: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Names.MethodSig: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Leaf: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Node: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Production: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Reduce: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Shift: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Scanner.Token: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x$19: List[String]) ===> Ast.ArrayType: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x$19: List[String]) ===> Ast.ImportClass: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x$19: List[String]) ===> Ast.ImportStar: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x$19: List[String]) ===> Ast.Name: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x$19: List[String]) ===> Ast.RefType: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x$19: List[String]) ===> Names.ConstrSig: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x$19: List[String]) ===> Names.MethodSig: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x$19: List[String]) ===> Parser.Leaf: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x$19: List[String]) ===> Parser.Node: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x$19: List[String]) ===> Parser.Production: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x$19: List[String]) ===> Parser.Reduce: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x$19: List[String]) ===> Parser.Shift: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x$19: List[String]) ===> Scanner.Token: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x0$1: Ast.TypeSpec, String) ===> Ast$ArraySpec: typ()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x0$1: Ast.TypeSpec, String) ===> Ast$ArrayType: spec()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x0$1: Ast.TypeSpec, String) ===> Ast$BooleanSpec: typ()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x0$1: Ast.TypeSpec, String) ===> Ast$BooleanType$: spec()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x0$1: Ast.TypeSpec, String) ===> Ast$ByteSpec: typ()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x0$1: Ast.TypeSpec, String) ===> Ast$ByteType$: spec()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x0$1: Ast.TypeSpec, String) ===> Ast$CharSpec: typ()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x0$1: Ast.TypeSpec, String) ===> Ast$CharType$: spec()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x0$1: Ast.TypeSpec, String) ===> Ast$IntSpec: typ()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x0$1: Ast.TypeSpec, String) ===> Ast$IntType$: spec()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x0$1: Ast.TypeSpec, String) ===> Ast$NullType$: spec()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x0$1: Ast.TypeSpec, String) ===> Ast$RefSpec: typ()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x0$1: Ast.TypeSpec, String) ===> Ast$RefType: spec()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x0$1: Ast.TypeSpec, String) ===> Ast$ShortSpec: typ()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x0$1: Ast.TypeSpec, String) ===> Ast$ShortType$: spec()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x0$1: Ast.TypeSpec, String) ===> Ast$VoidSpec: typ()
Names.$anonfun.$anonfun.$anonfun.$anonfun: apply(x0$1: Ast.TypeSpec, String) ===> Ast$VoidType$: spec()
Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast$ArraySpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast$ArrayType: spec()
Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast$BooleanSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast$BooleanType$: spec()
Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast$ByteSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast$ByteType$: spec()
Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast$CharSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast$CharType$: spec()
Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast$IntSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast$IntType$: spec()
Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast$NullType$: spec()
Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast$RefSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast$RefType: spec()
Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast$ShortSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast$ShortType$: spec()
Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast$VoidSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(m: Ast.MethodDecl) ===> Ast$VoidType$: spec()
Names.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33: Names$$anonfun$$anonfun$$$outer()
Names.$anonfun.$anonfun.$anonfun: apply(name: Ast.Name) ===> Ast.ArrayType: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(name: Ast.Name) ===> Ast.ImportClass: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(name: Ast.Name) ===> Ast.ImportStar: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(name: Ast.Name) ===> Ast.Name: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(name: Ast.Name) ===> Ast.RefType: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(name: Ast.Name) ===> Names$$anonfun$checkSingleTypeImports$1$1$$anonfun$apply$15: Names$$anonfun$$anonfun$$$outer()
Names.$anonfun.$anonfun.$anonfun: apply(name: Ast.Name) ===> Names.ConstrSig: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(name: Ast.Name) ===> Names.MethodSig: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(name: Ast.Name) ===> Parser.Leaf: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(name: Ast.Name) ===> Parser.Node: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(name: Ast.Name) ===> Parser.Production: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(name: Ast.Name) ===> Parser.Reduce: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(name: Ast.Name) ===> Parser.Shift: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(name: Ast.Name) ===> Scanner.Token: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(x$36: Ast.TypeSpec) ===> Ast$ArraySpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(x$36: Ast.TypeSpec) ===> Ast$BooleanSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(x$36: Ast.TypeSpec) ===> Ast$ByteSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(x$36: Ast.TypeSpec) ===> Ast$CharSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(x$36: Ast.TypeSpec) ===> Ast$IntSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(x$36: Ast.TypeSpec) ===> Ast$RefSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(x$36: Ast.TypeSpec) ===> Ast$ShortSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(x$36: Ast.TypeSpec) ===> Ast$VoidSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Ast$ArraySpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Ast$BooleanSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Ast$ByteSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Ast$CharSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Ast$IntSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Ast$RefSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Ast$ShortSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Ast$VoidSpec: typ()
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Ast.ArrayType: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Ast.ImportClass: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Ast.ImportStar: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Ast.Name: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Ast.RefType: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Names.ConstrSig: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Names.MethodSig: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Parser.Leaf: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Parser.Node: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Parser.Production: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Parser.Reduce: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Parser.Shift: equals(x$1: Any)
Names.$anonfun.$anonfun.$anonfun: apply(x$37: Ast.MethodDecl, Ast.MethodDecl) ===> Scanner.Token: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.ArrayType: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.ImportClass: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.ImportStar: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.Name: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.RefType: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Names.ConstrSig: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Names.MethodSig: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Leaf: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Node: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Production: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Reduce: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Shift: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Scanner.Token: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(prefix: List[String]) ===> Ast.ArrayType: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(prefix: List[String]) ===> Ast.ImportClass: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(prefix: List[String]) ===> Ast.ImportStar: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(prefix: List[String]) ===> Ast.Name: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(prefix: List[String]) ===> Ast.RefType: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(prefix: List[String]) ===> Names.ConstrSig: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(prefix: List[String]) ===> Names.MethodSig: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(prefix: List[String]) ===> Parser.Leaf: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(prefix: List[String]) ===> Parser.Node: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(prefix: List[String]) ===> Parser.Production: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(prefix: List[String]) ===> Parser.Reduce: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(prefix: List[String]) ===> Parser.Shift: equals(x$1: Any)
Names.$anonfun.$anonfun: apply(prefix: List[String]) ===> Scanner.Token: equals(x$1: Any)
Names.$anonfun.$anonfun: checkCirc(cd: Ast.ClassDecl) ===> Ast.ArrayType: equals(x$1: Any)
Names.$anonfun.$anonfun: checkCirc(cd: Ast.ClassDecl) ===> Ast.ImportClass: equals(x$1: Any)
Names.$anonfun.$anonfun: checkCirc(cd: Ast.ClassDecl) ===> Ast.ImportStar: equals(x$1: Any)
Names.$anonfun.$anonfun: checkCirc(cd: Ast.ClassDecl) ===> Ast.Name: equals(x$1: Any)
Names.$anonfun.$anonfun: checkCirc(cd: Ast.ClassDecl) ===> Ast.RefType: equals(x$1: Any)
Names.$anonfun.$anonfun: checkCirc(cd: Ast.ClassDecl) ===> Names.ConstrSig: equals(x$1: Any)
Names.$anonfun.$anonfun: checkCirc(cd: Ast.ClassDecl) ===> Names.MethodSig: equals(x$1: Any)
Names.$anonfun.$anonfun: checkCirc(cd: Ast.ClassDecl) ===> Parser.Leaf: equals(x$1: Any)
Names.$anonfun.$anonfun: checkCirc(cd: Ast.ClassDecl) ===> Parser.Node: equals(x$1: Any)
Names.$anonfun.$anonfun: checkCirc(cd: Ast.ClassDecl) ===> Parser.Production: equals(x$1: Any)
Names.$anonfun.$anonfun: checkCirc(cd: Ast.ClassDecl) ===> Parser.Reduce: equals(x$1: Any)
Names.$anonfun.$anonfun: checkCirc(cd: Ast.ClassDecl) ===> Parser.Shift: equals(x$1: Any)
Names.$anonfun.$anonfun: checkCirc(cd: Ast.ClassDecl) ===> Scanner.Token: equals(x$1: Any)
Names.$anonfun: apply(i: Ast.TypeSpec) ===> Ast$ArraySpec: typ()
Names.$anonfun: apply(i: Ast.TypeSpec) ===> Ast$BooleanSpec: typ()
Names.$anonfun: apply(i: Ast.TypeSpec) ===> Ast$ByteSpec: typ()
Names.$anonfun: apply(i: Ast.TypeSpec) ===> Ast$CharSpec: typ()
Names.$anonfun: apply(i: Ast.TypeSpec) ===> Ast$IntSpec: typ()
Names.$anonfun: apply(i: Ast.TypeSpec) ===> Ast$RefSpec: typ()
Names.$anonfun: apply(i: Ast.TypeSpec) ===> Ast$ShortSpec: typ()
Names.$anonfun: apply(i: Ast.TypeSpec) ===> Ast$VoidSpec: typ()
Names.ConstrSig.$anonfun: apply(x0$3: Ast.TypeSpec, String) ===> Ast$ArraySpec: typ()
Names.ConstrSig.$anonfun: apply(x0$3: Ast.TypeSpec, String) ===> Ast$BooleanSpec: typ()
Names.ConstrSig.$anonfun: apply(x0$3: Ast.TypeSpec, String) ===> Ast$ByteSpec: typ()
Names.ConstrSig.$anonfun: apply(x0$3: Ast.TypeSpec, String) ===> Ast$CharSpec: typ()
Names.ConstrSig.$anonfun: apply(x0$3: Ast.TypeSpec, String) ===> Ast$IntSpec: typ()
Names.ConstrSig.$anonfun: apply(x0$3: Ast.TypeSpec, String) ===> Ast$RefSpec: typ()
Names.ConstrSig.$anonfun: apply(x0$3: Ast.TypeSpec, String) ===> Ast$ShortSpec: typ()
Names.ConstrSig.$anonfun: apply(x0$3: Ast.TypeSpec, String) ===> Ast$VoidSpec: typ()
Names.ConstrSig: equals(x$1: Any) ===> Ast.ArrayType: equals(x$1: Any)
Names.ConstrSig: equals(x$1: Any) ===> Ast.ImportClass: equals(x$1: Any)
Names.ConstrSig: equals(x$1: Any) ===> Ast.ImportStar: equals(x$1: Any)
Names.ConstrSig: equals(x$1: Any) ===> Ast.Name: equals(x$1: Any)
Names.ConstrSig: equals(x$1: Any) ===> Ast.RefType: equals(x$1: Any)
Names.ConstrSig: equals(x$1: Any) ===> Names.ConstrSig: equals(x$1: Any)
Names.ConstrSig: equals(x$1: Any) ===> Names.MethodSig: equals(x$1: Any)
Names.ConstrSig: equals(x$1: Any) ===> Parser.Leaf: equals(x$1: Any)
Names.ConstrSig: equals(x$1: Any) ===> Parser.Node: equals(x$1: Any)
Names.ConstrSig: equals(x$1: Any) ===> Parser.Production: equals(x$1: Any)
Names.ConstrSig: equals(x$1: Any) ===> Parser.Reduce: equals(x$1: Any)
Names.ConstrSig: equals(x$1: Any) ===> Parser.Shift: equals(x$1: Any)
Names.ConstrSig: equals(x$1: Any) ===> Scanner.Token: equals(x$1: Any)
Names.ConstrSig: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.ByteType: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.CharType: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.IntType: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.Modifier: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.Name: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.NullType: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.RefType: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.ShortType: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.VoidType: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Names.Env: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Names.MethodSig: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Parser.Leaf: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Parser.Node: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Parser.Production: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Parser.Reduce: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Parser.Shift: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Scanner.Token: toString()
Names.ConstrSig: productElement(x$1: Int) ===> Util$Memoize: toString()
Names.Env.$anonfun: apply(full: Ast.Name) ===> Ast.ArrayType: equals(x$1: Any)
Names.Env.$anonfun: apply(full: Ast.Name) ===> Ast.ImportClass: equals(x$1: Any)
Names.Env.$anonfun: apply(full: Ast.Name) ===> Ast.ImportStar: equals(x$1: Any)
Names.Env.$anonfun: apply(full: Ast.Name) ===> Ast.Name: equals(x$1: Any)
Names.Env.$anonfun: apply(full: Ast.Name) ===> Ast.RefType: equals(x$1: Any)
Names.Env.$anonfun: apply(full: Ast.Name) ===> Names.ConstrSig: equals(x$1: Any)
Names.Env.$anonfun: apply(full: Ast.Name) ===> Names.MethodSig: equals(x$1: Any)
Names.Env.$anonfun: apply(full: Ast.Name) ===> Parser.Leaf: equals(x$1: Any)
Names.Env.$anonfun: apply(full: Ast.Name) ===> Parser.Node: equals(x$1: Any)
Names.Env.$anonfun: apply(full: Ast.Name) ===> Parser.Production: equals(x$1: Any)
Names.Env.$anonfun: apply(full: Ast.Name) ===> Parser.Reduce: equals(x$1: Any)
Names.Env.$anonfun: apply(full: Ast.Name) ===> Parser.Shift: equals(x$1: Any)
Names.Env.$anonfun: apply(full: Ast.Name) ===> Scanner.Token: equals(x$1: Any)
Names.Env.$anonfun: apply(prefix: List[String]) ===> Ast.ArrayType: equals(x$1: Any)
Names.Env.$anonfun: apply(prefix: List[String]) ===> Ast.ImportClass: equals(x$1: Any)
Names.Env.$anonfun: apply(prefix: List[String]) ===> Ast.ImportStar: equals(x$1: Any)
Names.Env.$anonfun: apply(prefix: List[String]) ===> Ast.Name: equals(x$1: Any)
Names.Env.$anonfun: apply(prefix: List[String]) ===> Ast.RefType: equals(x$1: Any)
Names.Env.$anonfun: apply(prefix: List[String]) ===> Names.ConstrSig: equals(x$1: Any)
Names.Env.$anonfun: apply(prefix: List[String]) ===> Names.MethodSig: equals(x$1: Any)
Names.Env.$anonfun: apply(prefix: List[String]) ===> Parser.Leaf: equals(x$1: Any)
Names.Env.$anonfun: apply(prefix: List[String]) ===> Parser.Node: equals(x$1: Any)
Names.Env.$anonfun: apply(prefix: List[String]) ===> Parser.Production: equals(x$1: Any)
Names.Env.$anonfun: apply(prefix: List[String]) ===> Parser.Reduce: equals(x$1: Any)
Names.Env.$anonfun: apply(prefix: List[String]) ===> Parser.Shift: equals(x$1: Any)
Names.Env.$anonfun: apply(prefix: List[String]) ===> Scanner.Token: equals(x$1: Any)
Names.Env.$anonfun: apply(x$8: Ast.FieldDecl) ===> Ast.ArrayType: equals(x$1: Any)
Names.Env.$anonfun: apply(x$8: Ast.FieldDecl) ===> Ast.ImportClass: equals(x$1: Any)
Names.Env.$anonfun: apply(x$8: Ast.FieldDecl) ===> Ast.ImportStar: equals(x$1: Any)
Names.Env.$anonfun: apply(x$8: Ast.FieldDecl) ===> Ast.Name: equals(x$1: Any)
Names.Env.$anonfun: apply(x$8: Ast.FieldDecl) ===> Ast.RefType: equals(x$1: Any)
Names.Env.$anonfun: apply(x$8: Ast.FieldDecl) ===> Names.ConstrSig: equals(x$1: Any)
Names.Env.$anonfun: apply(x$8: Ast.FieldDecl) ===> Names.MethodSig: equals(x$1: Any)
Names.Env.$anonfun: apply(x$8: Ast.FieldDecl) ===> Parser.Leaf: equals(x$1: Any)
Names.Env.$anonfun: apply(x$8: Ast.FieldDecl) ===> Parser.Node: equals(x$1: Any)
Names.Env.$anonfun: apply(x$8: Ast.FieldDecl) ===> Parser.Production: equals(x$1: Any)
Names.Env.$anonfun: apply(x$8: Ast.FieldDecl) ===> Parser.Reduce: equals(x$1: Any)
Names.Env.$anonfun: apply(x$8: Ast.FieldDecl) ===> Parser.Shift: equals(x$1: Any)
Names.Env.$anonfun: apply(x$8: Ast.FieldDecl) ===> Scanner.Token: equals(x$1: Any)
Names.Env: addVar(name: String,ts: Ast.TypeSpec) ===> Ast.ArrayType: equals(x$1: Any)
Names.Env: addVar(name: String,ts: Ast.TypeSpec) ===> Ast.ImportClass: equals(x$1: Any)
Names.Env: addVar(name: String,ts: Ast.TypeSpec) ===> Ast.ImportStar: equals(x$1: Any)
Names.Env: addVar(name: String,ts: Ast.TypeSpec) ===> Ast.Name: equals(x$1: Any)
Names.Env: addVar(name: String,ts: Ast.TypeSpec) ===> Ast.RefType: equals(x$1: Any)
Names.Env: addVar(name: String,ts: Ast.TypeSpec) ===> Names.ConstrSig: equals(x$1: Any)
Names.Env: addVar(name: String,ts: Ast.TypeSpec) ===> Names.MethodSig: equals(x$1: Any)
Names.Env: addVar(name: String,ts: Ast.TypeSpec) ===> Parser.Leaf: equals(x$1: Any)
Names.Env: addVar(name: String,ts: Ast.TypeSpec) ===> Parser.Node: equals(x$1: Any)
Names.Env: addVar(name: String,ts: Ast.TypeSpec) ===> Parser.Production: equals(x$1: Any)
Names.Env: addVar(name: String,ts: Ast.TypeSpec) ===> Parser.Reduce: equals(x$1: Any)
Names.Env: addVar(name: String,ts: Ast.TypeSpec) ===> Parser.Shift: equals(x$1: Any)
Names.Env: addVar(name: String,ts: Ast.TypeSpec) ===> Scanner.Token: equals(x$1: Any)
Names.Env: classes() ===> Names$Env: classes$lzycompute()
Names.Env: constrs() ===> Names$Env: constrs$lzycompute()
Names.Env: doResolveClass(name: Ast.Name) ===> Ast.ArrayType: equals(x$1: Any)
Names.Env: doResolveClass(name: Ast.Name) ===> Ast.ImportClass: equals(x$1: Any)
Names.Env: doResolveClass(name: Ast.Name) ===> Ast.ImportStar: equals(x$1: Any)
Names.Env: doResolveClass(name: Ast.Name) ===> Ast.Name: equals(x$1: Any)
Names.Env: doResolveClass(name: Ast.Name) ===> Ast.RefType: equals(x$1: Any)
Names.Env: doResolveClass(name: Ast.Name) ===> Names.ConstrSig: equals(x$1: Any)
Names.Env: doResolveClass(name: Ast.Name) ===> Names.MethodSig: equals(x$1: Any)
Names.Env: doResolveClass(name: Ast.Name) ===> Parser.Leaf: equals(x$1: Any)
Names.Env: doResolveClass(name: Ast.Name) ===> Parser.Node: equals(x$1: Any)
Names.Env: doResolveClass(name: Ast.Name) ===> Parser.Production: equals(x$1: Any)
Names.Env: doResolveClass(name: Ast.Name) ===> Parser.Reduce: equals(x$1: Any)
Names.Env: doResolveClass(name: Ast.Name) ===> Parser.Shift: equals(x$1: Any)
Names.Env: doResolveClass(name: Ast.Name) ===> Scanner.Token: equals(x$1: Any)
Names.Env: fields() ===> Names$Env: fields$lzycompute()
Names.Env: methods() ===> Names$Env: methods$lzycompute()
Names.FieldCheck.$anonfun.$anonfun: apply(fp: Ast.FieldDecl) ===> Ast.ArrayType: equals(x$1: Any)
Names.FieldCheck.$anonfun.$anonfun: apply(fp: Ast.FieldDecl) ===> Ast.ImportClass: equals(x$1: Any)
Names.FieldCheck.$anonfun.$anonfun: apply(fp: Ast.FieldDecl) ===> Ast.ImportStar: equals(x$1: Any)
Names.FieldCheck.$anonfun.$anonfun: apply(fp: Ast.FieldDecl) ===> Ast.Name: equals(x$1: Any)
Names.FieldCheck.$anonfun.$anonfun: apply(fp: Ast.FieldDecl) ===> Ast.RefType: equals(x$1: Any)
Names.FieldCheck.$anonfun.$anonfun: apply(fp: Ast.FieldDecl) ===> Names.ConstrSig: equals(x$1: Any)
Names.FieldCheck.$anonfun.$anonfun: apply(fp: Ast.FieldDecl) ===> Names.MethodSig: equals(x$1: Any)
Names.FieldCheck.$anonfun.$anonfun: apply(fp: Ast.FieldDecl) ===> Parser.Leaf: equals(x$1: Any)
Names.FieldCheck.$anonfun.$anonfun: apply(fp: Ast.FieldDecl) ===> Parser.Node: equals(x$1: Any)
Names.FieldCheck.$anonfun.$anonfun: apply(fp: Ast.FieldDecl) ===> Parser.Production: equals(x$1: Any)
Names.FieldCheck.$anonfun.$anonfun: apply(fp: Ast.FieldDecl) ===> Parser.Reduce: equals(x$1: Any)
Names.FieldCheck.$anonfun.$anonfun: apply(fp: Ast.FieldDecl) ===> Parser.Shift: equals(x$1: Any)
Names.FieldCheck.$anonfun.$anonfun: apply(fp: Ast.FieldDecl) ===> Scanner.Token: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.ArrayType: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.ImportClass: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.ImportStar: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.Name: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.RefType: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55: Names$MethodCheck$$anonfun$$anonfun$$anonfun$$$outer()
Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54: Names$MethodCheck$$anonfun$$anonfun$$$outer()
Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Names.ConstrSig: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Names.MethodSig: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Leaf: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Node: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Production: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Reduce: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Shift: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Scanner.Token: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.ArrayType: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.ImportClass: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.ImportStar: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.Name: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.RefType: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Names.ConstrSig: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Names.MethodSig: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Leaf: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Node: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Production: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Reduce: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Shift: equals(x$1: Any)
Names.MethodCheck.$anonfun.$anonfun: apply(mp: Ast.MethodDecl) ===> Scanner.Token: equals(x$1: Any)
Names.MethodCheck.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.ArrayType: equals(x$1: Any)
Names.MethodCheck.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.ImportClass: equals(x$1: Any)
Names.MethodCheck.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.ImportStar: equals(x$1: Any)
Names.MethodCheck.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.Name: equals(x$1: Any)
Names.MethodCheck.$anonfun: apply(mp: Ast.MethodDecl) ===> Ast.RefType: equals(x$1: Any)
Names.MethodCheck.$anonfun: apply(mp: Ast.MethodDecl) ===> Names.ConstrSig: equals(x$1: Any)
Names.MethodCheck.$anonfun: apply(mp: Ast.MethodDecl) ===> Names.MethodSig: equals(x$1: Any)
Names.MethodCheck.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Leaf: equals(x$1: Any)
Names.MethodCheck.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Node: equals(x$1: Any)
Names.MethodCheck.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Production: equals(x$1: Any)
Names.MethodCheck.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Reduce: equals(x$1: Any)
Names.MethodCheck.$anonfun: apply(mp: Ast.MethodDecl) ===> Parser.Shift: equals(x$1: Any)
Names.MethodCheck.$anonfun: apply(mp: Ast.MethodDecl) ===> Scanner.Token: equals(x$1: Any)
Names.MethodSig.$anonfun: apply(x0$2: Ast.TypeSpec, String) ===> Ast$ArraySpec: typ()
Names.MethodSig.$anonfun: apply(x0$2: Ast.TypeSpec, String) ===> Ast$BooleanSpec: typ()
Names.MethodSig.$anonfun: apply(x0$2: Ast.TypeSpec, String) ===> Ast$ByteSpec: typ()
Names.MethodSig.$anonfun: apply(x0$2: Ast.TypeSpec, String) ===> Ast$CharSpec: typ()
Names.MethodSig.$anonfun: apply(x0$2: Ast.TypeSpec, String) ===> Ast$IntSpec: typ()
Names.MethodSig.$anonfun: apply(x0$2: Ast.TypeSpec, String) ===> Ast$RefSpec: typ()
Names.MethodSig.$anonfun: apply(x0$2: Ast.TypeSpec, String) ===> Ast$ShortSpec: typ()
Names.MethodSig.$anonfun: apply(x0$2: Ast.TypeSpec, String) ===> Ast$VoidSpec: typ()
Names.MethodSig: equals(x$1: Any) ===> Ast.ArrayType: equals(x$1: Any)
Names.MethodSig: equals(x$1: Any) ===> Ast.ImportClass: equals(x$1: Any)
Names.MethodSig: equals(x$1: Any) ===> Ast.ImportStar: equals(x$1: Any)
Names.MethodSig: equals(x$1: Any) ===> Ast.Name: equals(x$1: Any)
Names.MethodSig: equals(x$1: Any) ===> Ast.RefType: equals(x$1: Any)
Names.MethodSig: equals(x$1: Any) ===> Names.ConstrSig: equals(x$1: Any)
Names.MethodSig: equals(x$1: Any) ===> Names.MethodSig: equals(x$1: Any)
Names.MethodSig: equals(x$1: Any) ===> Parser.Leaf: equals(x$1: Any)
Names.MethodSig: equals(x$1: Any) ===> Parser.Node: equals(x$1: Any)
Names.MethodSig: equals(x$1: Any) ===> Parser.Production: equals(x$1: Any)
Names.MethodSig: equals(x$1: Any) ===> Parser.Reduce: equals(x$1: Any)
Names.MethodSig: equals(x$1: Any) ===> Parser.Shift: equals(x$1: Any)
Names.MethodSig: equals(x$1: Any) ===> Scanner.Token: equals(x$1: Any)
Names.MethodSig: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.ByteType: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.CharType: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.IntType: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.Modifier: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.Name: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.NullType: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.RefType: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.ShortType: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.VoidType: toString()
Names.MethodSig: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Names.MethodSig: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Names.MethodSig: productElement(x$1: Int) ===> Names.Env: toString()
Names.MethodSig: productElement(x$1: Int) ===> Names.MethodSig: toString()
Names.MethodSig: productElement(x$1: Int) ===> Parser.Leaf: toString()
Names.MethodSig: productElement(x$1: Int) ===> Parser.Node: toString()
Names.MethodSig: productElement(x$1: Int) ===> Parser.Production: toString()
Names.MethodSig: productElement(x$1: Int) ===> Parser.Reduce: toString()
Names.MethodSig: productElement(x$1: Int) ===> Parser.Shift: toString()
Names.MethodSig: productElement(x$1: Int) ===> Scanner.Token: toString()
Names.MethodSig: productElement(x$1: Int) ===> Util$Memoize: toString()
Names: isJLO(cd: Ast.ClassDecl) ===> Ast.ArrayType: equals(x$1: Any)
Names: isJLO(cd: Ast.ClassDecl) ===> Ast.ImportClass: equals(x$1: Any)
Names: isJLO(cd: Ast.ClassDecl) ===> Ast.ImportStar: equals(x$1: Any)
Names: isJLO(cd: Ast.ClassDecl) ===> Ast.Name: equals(x$1: Any)
Names: isJLO(cd: Ast.ClassDecl) ===> Ast.RefType: equals(x$1: Any)
Names: isJLO(cd: Ast.ClassDecl) ===> Names.ConstrSig: equals(x$1: Any)
Names: isJLO(cd: Ast.ClassDecl) ===> Names.MethodSig: equals(x$1: Any)
Names: isJLO(cd: Ast.ClassDecl) ===> Parser.Leaf: equals(x$1: Any)
Names: isJLO(cd: Ast.ClassDecl) ===> Parser.Node: equals(x$1: Any)
Names: isJLO(cd: Ast.ClassDecl) ===> Parser.Production: equals(x$1: Any)
Names: isJLO(cd: Ast.ClassDecl) ===> Parser.Reduce: equals(x$1: Any)
Names: isJLO(cd: Ast.ClassDecl) ===> Parser.Shift: equals(x$1: Any)
Names: isJLO(cd: Ast.ClassDecl) ===> Scanner.Token: equals(x$1: Any)
Names: isSubtypeEq(cd1: Ast.ClassDecl,cd2: Ast.ClassDecl) ===> Ast.ArrayType: equals(x$1: Any)
Names: isSubtypeEq(cd1: Ast.ClassDecl,cd2: Ast.ClassDecl) ===> Ast.ImportClass: equals(x$1: Any)
Names: isSubtypeEq(cd1: Ast.ClassDecl,cd2: Ast.ClassDecl) ===> Ast.ImportStar: equals(x$1: Any)
Names: isSubtypeEq(cd1: Ast.ClassDecl,cd2: Ast.ClassDecl) ===> Ast.Name: equals(x$1: Any)
Names: isSubtypeEq(cd1: Ast.ClassDecl,cd2: Ast.ClassDecl) ===> Ast.RefType: equals(x$1: Any)
Names: isSubtypeEq(cd1: Ast.ClassDecl,cd2: Ast.ClassDecl) ===> Names.ConstrSig: equals(x$1: Any)
Names: isSubtypeEq(cd1: Ast.ClassDecl,cd2: Ast.ClassDecl) ===> Names.MethodSig: equals(x$1: Any)
Names: isSubtypeEq(cd1: Ast.ClassDecl,cd2: Ast.ClassDecl) ===> Parser.Leaf: equals(x$1: Any)
Names: isSubtypeEq(cd1: Ast.ClassDecl,cd2: Ast.ClassDecl) ===> Parser.Node: equals(x$1: Any)
Names: isSubtypeEq(cd1: Ast.ClassDecl,cd2: Ast.ClassDecl) ===> Parser.Production: equals(x$1: Any)
Names: isSubtypeEq(cd1: Ast.ClassDecl,cd2: Ast.ClassDecl) ===> Parser.Reduce: equals(x$1: Any)
Names: isSubtypeEq(cd1: Ast.ClassDecl,cd2: Ast.ClassDecl) ===> Parser.Shift: equals(x$1: Any)
Names: isSubtypeEq(cd1: Ast.ClassDecl,cd2: Ast.ClassDecl) ===> Scanner.Token: equals(x$1: Any)
Names: main(args: Array[String]) ===> Names: main(args: Array[String])
Parser$$anon$1$$anonfun$1: apply(Ljava/lang/Object;) ===> Parser.$anon.$anonfun: apply(line: String)
Parser$$anon$1$$anonfun$2: apply(Ljava/lang/Object;) ===> Parser.$anon.$anonfun: apply(line: String)
Parser$$anonfun$main$1: apply(Ljava/lang/Object;) ===> Parser.$anonfun: apply(token: Scanner.Token)
Parser$$anonfun$parse$1$$anonfun$go$1$1: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Parser$$anonfun$parse$1$$anonfun$go$1$1: apply(Ljava/lang/Object;) ===> Parser.$anonfun.$anonfun: apply(x$3: String)
Parser$$anonfun$parse$1: apply(Ljava/lang/Object;) ===> Parser.$anonfun: apply(a: Scanner.Token)
Parser$$anonfun$Parser$$nlines$1$1: apply(Ljava/lang/Object;) ===> Parser.$anonfun: apply(x$2: String)
Parser$: <clinit>() ===> Parser: <init>()
Parser$Leaf: asNode() ===> Parser.Leaf: asNode()
Parser$Node$$anonfun$toString$1: apply(Ljava/lang/Object;) ===> Parser.Node.$anonfun: apply(x$1: Parser.Tree)
Parser$Node: asLeaf() ===> Parser.Node: asLeaf()
Parser.$anon.$anonfun: apply(line: String) ===> Ast.ArrayType: equals(x$1: Any)
Parser.$anon.$anonfun: apply(line: String) ===> Ast.ImportClass: equals(x$1: Any)
Parser.$anon.$anonfun: apply(line: String) ===> Ast.ImportStar: equals(x$1: Any)
Parser.$anon.$anonfun: apply(line: String) ===> Ast.Name: equals(x$1: Any)
Parser.$anon.$anonfun: apply(line: String) ===> Ast.RefType: equals(x$1: Any)
Parser.$anon.$anonfun: apply(line: String) ===> Names.ConstrSig: equals(x$1: Any)
Parser.$anon.$anonfun: apply(line: String) ===> Names.MethodSig: equals(x$1: Any)
Parser.$anon.$anonfun: apply(line: String) ===> Parser.Leaf: equals(x$1: Any)
Parser.$anon.$anonfun: apply(line: String) ===> Parser.Node: equals(x$1: Any)
Parser.$anon.$anonfun: apply(line: String) ===> Parser.Production: equals(x$1: Any)
Parser.$anon.$anonfun: apply(line: String) ===> Parser.Reduce: equals(x$1: Any)
Parser.$anon.$anonfun: apply(line: String) ===> Parser.Shift: equals(x$1: Any)
Parser.$anon.$anonfun: apply(line: String) ===> Scanner.Token: equals(x$1: Any)
Parser.Leaf: asNode() ===> Ast.ArrayType: toString()
Parser.Leaf: asNode() ===> Ast.BinExpr: toString()
Parser.Leaf: asNode() ===> Ast.BooleanType: toString()
Parser.Leaf: asNode() ===> Ast.ByteType: toString()
Parser.Leaf: asNode() ===> Ast.CharType: toString()
Parser.Leaf: asNode() ===> Ast.ClassDecl: toString()
Parser.Leaf: asNode() ===> Ast.ExprStmt: toString()
Parser.Leaf: asNode() ===> Ast.FieldDecl: toString()
Parser.Leaf: asNode() ===> Ast.FieldExpr: toString()
Parser.Leaf: asNode() ===> Ast.ForStmt: toString()
Parser.Leaf: asNode() ===> Ast.IfStmt: toString()
Parser.Leaf: asNode() ===> Ast.ImportClass: toString()
Parser.Leaf: asNode() ===> Ast.ImportStar: toString()
Parser.Leaf: asNode() ===> Ast.InstanceOfExpr: toString()
Parser.Leaf: asNode() ===> Ast.IntType: toString()
Parser.Leaf: asNode() ===> Ast.InvokeExpr: toString()
Parser.Leaf: asNode() ===> Ast.MethodDecl: toString()
Parser.Leaf: asNode() ===> Ast.Modifier: toString()
Parser.Leaf: asNode() ===> Ast.Name: toString()
Parser.Leaf: asNode() ===> Ast.NewExpr: toString()
Parser.Leaf: asNode() ===> Ast.NullType: toString()
Parser.Leaf: asNode() ===> Ast.RefSpec: toString()
Parser.Leaf: asNode() ===> Ast.RefType: toString()
Parser.Leaf: asNode() ===> Ast.ReturnStmt: toString()
Parser.Leaf: asNode() ===> Ast.ShortType: toString()
Parser.Leaf: asNode() ===> Ast.ThisLiteral: toString()
Parser.Leaf: asNode() ===> Ast.TypeExpr: toString()
Parser.Leaf: asNode() ===> Ast.VarDeclStmt: toString()
Parser.Leaf: asNode() ===> Ast.VarExpr: toString()
Parser.Leaf: asNode() ===> Ast.VoidType: toString()
Parser.Leaf: asNode() ===> Ast.WhileStmt: toString()
Parser.Leaf: asNode() ===> Names.ConstrSig: toString()
Parser.Leaf: asNode() ===> Names.Env: toString()
Parser.Leaf: asNode() ===> Names.MethodSig: toString()
Parser.Leaf: asNode() ===> Parser.Node: toString()
Parser.Leaf: asNode() ===> Parser.Production: toString()
Parser.Leaf: asNode() ===> Parser.Reduce: toString()
Parser.Leaf: asNode() ===> Parser.Shift: toString()
Parser.Leaf: asNode() ===> Scanner.Token: toString()
Parser.Leaf: asNode() ===> Util$Memoize: toString()
Parser.Leaf: equals(x$1: Any) ===> Ast.ArrayType: equals(x$1: Any)
Parser.Leaf: equals(x$1: Any) ===> Ast.ImportClass: equals(x$1: Any)
Parser.Leaf: equals(x$1: Any) ===> Ast.ImportStar: equals(x$1: Any)
Parser.Leaf: equals(x$1: Any) ===> Ast.Name: equals(x$1: Any)
Parser.Leaf: equals(x$1: Any) ===> Ast.RefType: equals(x$1: Any)
Parser.Leaf: equals(x$1: Any) ===> Names.ConstrSig: equals(x$1: Any)
Parser.Leaf: equals(x$1: Any) ===> Names.MethodSig: equals(x$1: Any)
Parser.Leaf: equals(x$1: Any) ===> Parser.Leaf: equals(x$1: Any)
Parser.Leaf: equals(x$1: Any) ===> Parser.Node: equals(x$1: Any)
Parser.Leaf: equals(x$1: Any) ===> Parser.Production: equals(x$1: Any)
Parser.Leaf: equals(x$1: Any) ===> Parser.Reduce: equals(x$1: Any)
Parser.Leaf: equals(x$1: Any) ===> Parser.Shift: equals(x$1: Any)
Parser.Leaf: equals(x$1: Any) ===> Scanner.Token: equals(x$1: Any)
Parser.Leaf: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.ByteType: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.CharType: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.IntType: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.Modifier: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.Name: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.NullType: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.RefType: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.ShortType: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.VoidType: toString()
Parser.Leaf: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Parser.Leaf: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Parser.Leaf: productElement(x$1: Int) ===> Names.Env: toString()
Parser.Leaf: productElement(x$1: Int) ===> Names.MethodSig: toString()
Parser.Leaf: productElement(x$1: Int) ===> Parser.Leaf: toString()
Parser.Leaf: productElement(x$1: Int) ===> Parser.Node: toString()
Parser.Leaf: productElement(x$1: Int) ===> Parser.Production: toString()
Parser.Leaf: productElement(x$1: Int) ===> Parser.Reduce: toString()
Parser.Leaf: productElement(x$1: Int) ===> Parser.Shift: toString()
Parser.Leaf: productElement(x$1: Int) ===> Scanner.Token: toString()
Parser.Leaf: productElement(x$1: Int) ===> Util$Memoize: toString()
Parser.Leaf: toString(indent: String) ===> Ast.ArrayType: toString()
Parser.Leaf: toString(indent: String) ===> Ast.BinExpr: toString()
Parser.Leaf: toString(indent: String) ===> Ast.BooleanType: toString()
Parser.Leaf: toString(indent: String) ===> Ast.ByteType: toString()
Parser.Leaf: toString(indent: String) ===> Ast.CharType: toString()
Parser.Leaf: toString(indent: String) ===> Ast.ClassDecl: toString()
Parser.Leaf: toString(indent: String) ===> Ast.ExprStmt: toString()
Parser.Leaf: toString(indent: String) ===> Ast.FieldDecl: toString()
Parser.Leaf: toString(indent: String) ===> Ast.FieldExpr: toString()
Parser.Leaf: toString(indent: String) ===> Ast.ForStmt: toString()
Parser.Leaf: toString(indent: String) ===> Ast.IfStmt: toString()
Parser.Leaf: toString(indent: String) ===> Ast.ImportClass: toString()
Parser.Leaf: toString(indent: String) ===> Ast.ImportStar: toString()
Parser.Leaf: toString(indent: String) ===> Ast.InstanceOfExpr: toString()
Parser.Leaf: toString(indent: String) ===> Ast.IntType: toString()
Parser.Leaf: toString(indent: String) ===> Ast.InvokeExpr: toString()
Parser.Leaf: toString(indent: String) ===> Ast.MethodDecl: toString()
Parser.Leaf: toString(indent: String) ===> Ast.Modifier: toString()
Parser.Leaf: toString(indent: String) ===> Ast.Name: toString()
Parser.Leaf: toString(indent: String) ===> Ast.NewExpr: toString()
Parser.Leaf: toString(indent: String) ===> Ast.NullType: toString()
Parser.Leaf: toString(indent: String) ===> Ast.RefSpec: toString()
Parser.Leaf: toString(indent: String) ===> Ast.RefType: toString()
Parser.Leaf: toString(indent: String) ===> Ast.ReturnStmt: toString()
Parser.Leaf: toString(indent: String) ===> Ast.ShortType: toString()
Parser.Leaf: toString(indent: String) ===> Ast.ThisLiteral: toString()
Parser.Leaf: toString(indent: String) ===> Ast.TypeExpr: toString()
Parser.Leaf: toString(indent: String) ===> Ast.VarDeclStmt: toString()
Parser.Leaf: toString(indent: String) ===> Ast.VarExpr: toString()
Parser.Leaf: toString(indent: String) ===> Ast.VoidType: toString()
Parser.Leaf: toString(indent: String) ===> Ast.WhileStmt: toString()
Parser.Leaf: toString(indent: String) ===> Names.ConstrSig: toString()
Parser.Leaf: toString(indent: String) ===> Names.Env: toString()
Parser.Leaf: toString(indent: String) ===> Names.MethodSig: toString()
Parser.Leaf: toString(indent: String) ===> Parser.Node: toString()
Parser.Leaf: toString(indent: String) ===> Parser.Production: toString()
Parser.Leaf: toString(indent: String) ===> Parser.Reduce: toString()
Parser.Leaf: toString(indent: String) ===> Parser.Shift: toString()
Parser.Leaf: toString(indent: String) ===> Scanner.Token: toString()
Parser.Leaf: toString(indent: String) ===> Util$Memoize: toString()
Parser.Node: equals(x$1: Any) ===> Ast.ArrayType: equals(x$1: Any)
Parser.Node: equals(x$1: Any) ===> Ast.ImportClass: equals(x$1: Any)
Parser.Node: equals(x$1: Any) ===> Ast.ImportStar: equals(x$1: Any)
Parser.Node: equals(x$1: Any) ===> Ast.Name: equals(x$1: Any)
Parser.Node: equals(x$1: Any) ===> Ast.RefType: equals(x$1: Any)
Parser.Node: equals(x$1: Any) ===> Names.ConstrSig: equals(x$1: Any)
Parser.Node: equals(x$1: Any) ===> Names.MethodSig: equals(x$1: Any)
Parser.Node: equals(x$1: Any) ===> Parser.Leaf: equals(x$1: Any)
Parser.Node: equals(x$1: Any) ===> Parser.Node: equals(x$1: Any)
Parser.Node: equals(x$1: Any) ===> Parser.Production: equals(x$1: Any)
Parser.Node: equals(x$1: Any) ===> Parser.Reduce: equals(x$1: Any)
Parser.Node: equals(x$1: Any) ===> Parser.Shift: equals(x$1: Any)
Parser.Node: equals(x$1: Any) ===> Scanner.Token: equals(x$1: Any)
Parser.Node: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.ByteType: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.CharType: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.IntType: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.Modifier: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.Name: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.NullType: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.RefType: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.ShortType: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.VoidType: toString()
Parser.Node: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Parser.Node: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Parser.Node: productElement(x$1: Int) ===> Names.Env: toString()
Parser.Node: productElement(x$1: Int) ===> Names.MethodSig: toString()
Parser.Node: productElement(x$1: Int) ===> Parser.Leaf: toString()
Parser.Node: productElement(x$1: Int) ===> Parser.Node: toString()
Parser.Node: productElement(x$1: Int) ===> Parser.Production: toString()
Parser.Node: productElement(x$1: Int) ===> Parser.Reduce: toString()
Parser.Node: productElement(x$1: Int) ===> Parser.Shift: toString()
Parser.Node: productElement(x$1: Int) ===> Scanner.Token: toString()
Parser.Node: productElement(x$1: Int) ===> Util$Memoize: toString()
Parser.Production: equals(x$1: Any) ===> Ast.ArrayType: equals(x$1: Any)
Parser.Production: equals(x$1: Any) ===> Ast.ImportClass: equals(x$1: Any)
Parser.Production: equals(x$1: Any) ===> Ast.ImportStar: equals(x$1: Any)
Parser.Production: equals(x$1: Any) ===> Ast.Name: equals(x$1: Any)
Parser.Production: equals(x$1: Any) ===> Ast.RefType: equals(x$1: Any)
Parser.Production: equals(x$1: Any) ===> Names.ConstrSig: equals(x$1: Any)
Parser.Production: equals(x$1: Any) ===> Names.MethodSig: equals(x$1: Any)
Parser.Production: equals(x$1: Any) ===> Parser.Leaf: equals(x$1: Any)
Parser.Production: equals(x$1: Any) ===> Parser.Node: equals(x$1: Any)
Parser.Production: equals(x$1: Any) ===> Parser.Production: equals(x$1: Any)
Parser.Production: equals(x$1: Any) ===> Parser.Reduce: equals(x$1: Any)
Parser.Production: equals(x$1: Any) ===> Parser.Shift: equals(x$1: Any)
Parser.Production: equals(x$1: Any) ===> Scanner.Token: equals(x$1: Any)
Parser.Production: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.ByteType: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.CharType: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.IntType: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.Modifier: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.Name: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.NullType: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.RefType: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.ShortType: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.VoidType: toString()
Parser.Production: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Parser.Production: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Parser.Production: productElement(x$1: Int) ===> Names.Env: toString()
Parser.Production: productElement(x$1: Int) ===> Names.MethodSig: toString()
Parser.Production: productElement(x$1: Int) ===> Parser.Leaf: toString()
Parser.Production: productElement(x$1: Int) ===> Parser.Node: toString()
Parser.Production: productElement(x$1: Int) ===> Parser.Production: toString()
Parser.Production: productElement(x$1: Int) ===> Parser.Reduce: toString()
Parser.Production: productElement(x$1: Int) ===> Parser.Shift: toString()
Parser.Production: productElement(x$1: Int) ===> Scanner.Token: toString()
Parser.Production: productElement(x$1: Int) ===> Util$Memoize: toString()
Parser.Reduce: equals(x$1: Any) ===> Ast.ArrayType: equals(x$1: Any)
Parser.Reduce: equals(x$1: Any) ===> Ast.ImportClass: equals(x$1: Any)
Parser.Reduce: equals(x$1: Any) ===> Ast.ImportStar: equals(x$1: Any)
Parser.Reduce: equals(x$1: Any) ===> Ast.Name: equals(x$1: Any)
Parser.Reduce: equals(x$1: Any) ===> Ast.RefType: equals(x$1: Any)
Parser.Reduce: equals(x$1: Any) ===> Names.ConstrSig: equals(x$1: Any)
Parser.Reduce: equals(x$1: Any) ===> Names.MethodSig: equals(x$1: Any)
Parser.Reduce: equals(x$1: Any) ===> Parser.Leaf: equals(x$1: Any)
Parser.Reduce: equals(x$1: Any) ===> Parser.Node: equals(x$1: Any)
Parser.Reduce: equals(x$1: Any) ===> Parser.Production: equals(x$1: Any)
Parser.Reduce: equals(x$1: Any) ===> Parser.Reduce: equals(x$1: Any)
Parser.Reduce: equals(x$1: Any) ===> Parser.Shift: equals(x$1: Any)
Parser.Reduce: equals(x$1: Any) ===> Scanner.Token: equals(x$1: Any)
Parser.Reduce: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.ByteType: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.CharType: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.IntType: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.Modifier: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.Name: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.NullType: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.RefType: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.ShortType: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.VoidType: toString()
Parser.Reduce: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Parser.Reduce: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Parser.Reduce: productElement(x$1: Int) ===> Names.Env: toString()
Parser.Reduce: productElement(x$1: Int) ===> Names.MethodSig: toString()
Parser.Reduce: productElement(x$1: Int) ===> Parser.Leaf: toString()
Parser.Reduce: productElement(x$1: Int) ===> Parser.Node: toString()
Parser.Reduce: productElement(x$1: Int) ===> Parser.Production: toString()
Parser.Reduce: productElement(x$1: Int) ===> Parser.Reduce: toString()
Parser.Reduce: productElement(x$1: Int) ===> Parser.Shift: toString()
Parser.Reduce: productElement(x$1: Int) ===> Scanner.Token: toString()
Parser.Reduce: productElement(x$1: Int) ===> Util$Memoize: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.ByteType: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.CharType: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.IntType: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.Modifier: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.Name: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.NullType: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.RefType: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.ShortType: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.VoidType: toString()
Parser.Shift: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Parser.Shift: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Parser.Shift: productElement(x$1: Int) ===> Names.Env: toString()
Parser.Shift: productElement(x$1: Int) ===> Names.MethodSig: toString()
Parser.Shift: productElement(x$1: Int) ===> Parser.Leaf: toString()
Parser.Shift: productElement(x$1: Int) ===> Parser.Node: toString()
Parser.Shift: productElement(x$1: Int) ===> Parser.Production: toString()
Parser.Shift: productElement(x$1: Int) ===> Parser.Reduce: toString()
Parser.Shift: productElement(x$1: Int) ===> Parser.Shift: toString()
Parser.Shift: productElement(x$1: Int) ===> Scanner.Token: toString()
Parser.Shift: productElement(x$1: Int) ===> Util$Memoize: toString()
Parser.Tree: apply(i: Int) ===> Parser$Leaf: asNode()
Parser: main(args: Array[String]) ===> Parser: main(args: Array[String])
Scanner$$anonfun$1: apply(Ljava/lang/Object;Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Scanner$$anonfun$1: apply(Ljava/lang/Object;Ljava/lang/Object;) ===> Scanner.$anonfun: apply(q: Scanner.States.Value,sym: Char)
Scanner$$anonfun$2: apply(Ljava/lang/Object;) ===> Scanner.$anonfun: apply(q: Scanner.States.Value)
Scanner$$anonfun$main$1: apply(Ljava/lang/Object;) ===> Scanner.$anonfun: apply(token: Scanner.Token)
Scanner$$anonfun$maximalmunch$1: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Scanner$$anonfun$maximalmunch$1: apply(Ljava/lang/Object;) ===> Scanner.$anonfun: apply(x$1: Char)
Scanner$$anonfun$maximalmunch$2: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Scanner$$anonfun$maximalmunch$2: apply(Ljava/lang/Object;) ===> Scanner.$anonfun: apply(x$2: Char)
Scanner$: <clinit>() ===> Scanner: <init>()
Scanner$States$: <clinit>() ===> Scanner.States: <init>()
Scanner.$anonfun: apply(q: Scanner.States.Value) ===> Ast.ArrayType: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value) ===> Ast.ImportClass: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value) ===> Ast.ImportStar: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value) ===> Ast.Name: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value) ===> Ast.RefType: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value) ===> Names.ConstrSig: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value) ===> Names.MethodSig: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value) ===> Parser.Leaf: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value) ===> Parser.Node: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value) ===> Parser.Production: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value) ===> Parser.Reduce: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value) ===> Parser.Shift: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value) ===> Scanner.Token: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value,sym: Char) ===> Ast.ArrayType: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value,sym: Char) ===> Ast.ImportClass: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value,sym: Char) ===> Ast.ImportStar: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value,sym: Char) ===> Ast.Name: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value,sym: Char) ===> Ast.RefType: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value,sym: Char) ===> Names.ConstrSig: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value,sym: Char) ===> Names.MethodSig: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value,sym: Char) ===> Parser.Leaf: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value,sym: Char) ===> Parser.Node: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value,sym: Char) ===> Parser.Production: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value,sym: Char) ===> Parser.Reduce: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value,sym: Char) ===> Parser.Shift: equals(x$1: Any)
Scanner.$anonfun: apply(q: Scanner.States.Value,sym: Char) ===> Scanner.Token: equals(x$1: Any)
Scanner.Token: equals(x$1: Any) ===> Ast.ArrayType: equals(x$1: Any)
Scanner.Token: equals(x$1: Any) ===> Ast.ImportClass: equals(x$1: Any)
Scanner.Token: equals(x$1: Any) ===> Ast.ImportStar: equals(x$1: Any)
Scanner.Token: equals(x$1: Any) ===> Ast.Name: equals(x$1: Any)
Scanner.Token: equals(x$1: Any) ===> Ast.RefType: equals(x$1: Any)
Scanner.Token: equals(x$1: Any) ===> Names.ConstrSig: equals(x$1: Any)
Scanner.Token: equals(x$1: Any) ===> Names.MethodSig: equals(x$1: Any)
Scanner.Token: equals(x$1: Any) ===> Parser.Leaf: equals(x$1: Any)
Scanner.Token: equals(x$1: Any) ===> Parser.Node: equals(x$1: Any)
Scanner.Token: equals(x$1: Any) ===> Parser.Production: equals(x$1: Any)
Scanner.Token: equals(x$1: Any) ===> Parser.Reduce: equals(x$1: Any)
Scanner.Token: equals(x$1: Any) ===> Parser.Shift: equals(x$1: Any)
Scanner.Token: equals(x$1: Any) ===> Scanner.Token: equals(x$1: Any)
Scanner.Token: productElement(x$1: Int) ===> Ast.ArrayType: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.BinExpr: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.BooleanType: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.ByteType: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.CharType: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.ClassDecl: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.ExprStmt: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.FieldDecl: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.FieldExpr: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.ForStmt: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.IfStmt: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.ImportClass: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.ImportStar: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.InstanceOfExpr: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.IntType: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.InvokeExpr: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.MethodDecl: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.Modifier: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.Name: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.NewExpr: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.NullType: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.RefSpec: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.RefType: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.ReturnStmt: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.ShortType: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.ThisLiteral: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.TypeExpr: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.VarDeclStmt: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.VarExpr: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.VoidType: toString()
Scanner.Token: productElement(x$1: Int) ===> Ast.WhileStmt: toString()
Scanner.Token: productElement(x$1: Int) ===> Names.ConstrSig: toString()
Scanner.Token: productElement(x$1: Int) ===> Names.Env: toString()
Scanner.Token: productElement(x$1: Int) ===> Names.MethodSig: toString()
Scanner.Token: productElement(x$1: Int) ===> Parser.Leaf: toString()
Scanner.Token: productElement(x$1: Int) ===> Parser.Node: toString()
Scanner.Token: productElement(x$1: Int) ===> Parser.Production: toString()
Scanner.Token: productElement(x$1: Int) ===> Parser.Reduce: toString()
Scanner.Token: productElement(x$1: Int) ===> Parser.Shift: toString()
Scanner.Token: productElement(x$1: Int) ===> Scanner.Token: toString()
Scanner.Token: productElement(x$1: Int) ===> Util$Memoize: toString()
Scanner: main(args: Array[String]) ===> Scanner: main(args: Array[String])
Scanner: maximalmunch(in: Seq[Char]) ===> Ast$$anonfun$assertAllLinks$1$$anonfun$apply$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Ast$$anonfun$assertAllLinks$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Ast$$anonfun$assertLinks$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Ast$$anonfun$assertLinks$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Ast$$anonfun$ast_CastExpression$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Ast$$anonfun$ast_ClassDeclaration$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Ast$$anonfun$dfs$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Ast$$anonfun$expandEscapes$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Ast$$anonfun$main$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Ast$$anonfun$main$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Ast$AstNode$$anonfun$linkParents$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Ast$ConstructorDecl$$anonfun$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Ast$MethodDecl$$anonfun$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Ast.ArrayType: equals(x$1: Any)
Scanner: maximalmunch(in: Seq[Char]) ===> Ast.ImportClass: equals(x$1: Any)
Scanner: maximalmunch(in: Seq[Char]) ===> Ast.ImportStar: equals(x$1: Any)
Scanner: maximalmunch(in: Seq[Char]) ===> Ast.Name: equals(x$1: Any)
Scanner: maximalmunch(in: Seq[Char]) ===> Ast.RefType: equals(x$1: Any)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anon$2$$anonfun$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anon$3$$anonfun$8: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anon$3$$anonfun$code$4: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anon$4$$anonfun$code$5: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$7: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$9$$anonfun$apply$21: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$9$$anonfun$apply$22: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$9: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$arrayFrame$lzycompute$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$classFrame$lzycompute$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$3: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$4: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$5: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$15$$anonfun$apply$16: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$15: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$17: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$18: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$19$$anonfun$apply$20: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$19: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$6: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$13: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$10: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$11$$anonfun$apply$12: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$11: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$3: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$4: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$3: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$codeGen$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$constFrame$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$constFrame$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$constrSig$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$main$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$mainClass$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$makeFrame$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$makeFrame$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$methodFrame$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$methodFrame$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$methodSig$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$objectFrame$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$objectFrame$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$$anonfun$objectFrame$3: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$2$$anonfun$apply$3: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$interfaceInvoke$2$$anonfun$3: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$4: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$5: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$6: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$interfaceInvoke$2$$anonfun$code$3: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$subtypeTests$2$$anonfun$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$subtypeTests$2$$anonfun$code$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> CodeGen$subtypeTests$2$$anonfun$code$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> MakeAst$$anonfun$main$1$$anonfun$apply$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> MakeAst$$anonfun$main$1$$anonfun$apply$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> MakeAst$$anonfun$main$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$10: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$12$$anonfun$apply$76: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$12$$anonfun$apply$77: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$12: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$8: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$9: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$32: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$34: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$36: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$37: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$38: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addAbstractObjectMethods$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$39: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$40: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$11: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$43: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$44: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$45: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$46: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addAbstractObjectMethods$1$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addClasses$1$1$$anonfun$apply$5: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$addClasses$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$canonicalNames$1$1$$anonfun$apply$4: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$canonicalNames$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20$$anonfun$apply$21$$anonfun$apply$22: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20$$anonfun$apply$21: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkDemandPackageIsClass$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkHierarchyCycles$1$1$$anonfun$apply$31: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkHierarchyCycles$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$28: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$29$$anonfun$apply$30: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$29: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkInterfaceFields$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17$$anonfun$apply$18$$anonfun$apply$19: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17$$anonfun$apply$18: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkNonExistingPackage$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkPackageClashWithType$1$1$$anonfun$apply$25: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkPackageClashWithType$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkPrefixesOfReferences$1$1$$anonfun$apply$26: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkPrefixesOfReferences$1$1$$anonfun$apply$27: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkPrefixesOfReferences$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkSingleTypeImports$1$1$$anonfun$apply$15$$anonfun$apply$16: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkSingleTypeImports$1$1$$anonfun$apply$15: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$checkSingleTypeImports$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$demandImports$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$demImp$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$demImp$1$2$$anonfun$apply$23: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$demImp$1$2$$anonfun$apply$24: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$demImp$1$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$enclosingBlock$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$enclosingClass$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$environments$1$$anonfun$apply$14: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$environments$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$63: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$64: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$66: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$67: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$68: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$69: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$70: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$71: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$73: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$74: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$75: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$hierarchy$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$interfaces$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$isSubtype$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$main$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$makeEnvs$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$10: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$11: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$12$$anonfun$apply$13: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$12: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$6: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$7: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$8$$anonfun$apply$9: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$8: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$Names$$addMembers$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$Names$$dfs$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$resolveTypes$1$1$$anonfun$7: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$resolveTypes$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$singleImports$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$$anonfun$typeLinking$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$ConstrSig$$anonfun$apply$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$Env$$anonfun$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$Env$$anonfun$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$Env$$anonfun$4$$anonfun$apply$3: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$Env$$anonfun$5: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$Env$$anonfun$lookupClass$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$Env$$anonfun$Names$Env$$tryName$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$Env$$anonfun$resolveClass$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$FieldCheck$$anonfun$declare$3: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$FieldCheck$$anonfun$declare$4: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$FieldCheck$$anonfun$inherit$2$$anonfun$apply$61: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$FieldCheck$$anonfun$inherit$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$allabs$1$$anonfun$apply$47: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$allabs$1$$anonfun$apply$48: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$allabs$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$declare$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$declare$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$49: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$50: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$51: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$inherit$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$nodecl$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$replace$1$$anonfun$apply$53: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$replace$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$56: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$57: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$58: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$59: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$60: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$replace$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$replaceM$1$$anonfun$apply$52: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodCheck$$anonfun$replaceM$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names$MethodSig$$anonfun$apply$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Names.ConstrSig: equals(x$1: Any)
Scanner: maximalmunch(in: Seq[Char]) ===> Names.MethodSig: equals(x$1: Any)
Scanner: maximalmunch(in: Seq[Char]) ===> Parser$$anon$1$$anonfun$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Parser$$anon$1$$anonfun$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Parser$$anonfun$main$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Parser$$anonfun$parse$1$$anonfun$go$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Parser$$anonfun$parse$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Parser$$anonfun$Parser$$nlines$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Parser$Node$$anonfun$toString$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Parser.Leaf: equals(x$1: Any)
Scanner: maximalmunch(in: Seq[Char]) ===> Parser.Node: equals(x$1: Any)
Scanner: maximalmunch(in: Seq[Char]) ===> Parser.Production: equals(x$1: Any)
Scanner: maximalmunch(in: Seq[Char]) ===> Parser.Reduce: equals(x$1: Any)
Scanner: maximalmunch(in: Seq[Char]) ===> Parser.Shift: equals(x$1: Any)
Scanner: maximalmunch(in: Seq[Char]) ===> Scanner$$anonfun$1: apply(Ljava/lang/Object;Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Scanner$$anonfun$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Scanner$$anonfun$main$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Scanner$$anonfun$maximalmunch$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Scanner$$anonfun$maximalmunch$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Scanner.Token: equals(x$1: Any)
Scanner: maximalmunch(in: Seq[Char]) ===> StaticAnal$$anonfun$1$$anonfun$apply$3: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> StaticAnal$$anonfun$1$$anonfun$apply$4: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> StaticAnal$$anonfun$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> StaticAnal$$anonfun$definiteAssignment$1$$anonfun$apply$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> StaticAnal$$anonfun$definiteAssignment$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> StaticAnal$$anonfun$main$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> StaticAnal$$anonfun$reachability$1$$anonfun$apply$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> StaticAnal$$anonfun$reachability$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$3: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$4: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$5: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$6$$anonfun$apply$24: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$6$$anonfun$apply$25: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$6: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$checkAccess$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20$$anonfun$apply$21: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20$$anonfun$apply$22: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$checkConstructorNames$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$15: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$17: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$18: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$19: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$checkForwardReferences$1$1$$anonfun$apply$23: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$checkForwardReferences$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$checkTypes$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disambiguation$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disField$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disField$1$2$$anonfun$apply$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disField$1$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disField$1$3$$anonfun$apply$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disField$1$3: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disField$1$4$$anonfun$apply$3$$anonfun$apply$4: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disField$1$4$$anonfun$apply$3: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disField$1$4: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disField$1$5: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disField$1$6: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disInvoke$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$10: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$11: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$12: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$13: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$14: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$9: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$disLval$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$formalConf$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$main$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$Types$$disMethod$1$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$Types$$disMethod$1$2$$anonfun$apply$5: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$Types$$disMethod$1$2: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$Types$$disMethod$1$3$$anonfun$apply$6: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$Types$$disMethod$1$3: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$Types$$disMethod$1$4$$anonfun$apply$7$$anonfun$apply$8: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$Types$$disMethod$1$4$$anonfun$apply$7: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$Types$$disMethod$1$4: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$Types$$disMethod$1$5: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Types$$anonfun$Types$$disMethod$1$6: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Util$$anonfun$closure$1: apply(Ljava/lang/Object;)
Scanner: maximalmunch(in: Seq[Char]) ===> Util.Memoize: apply(k: Key)
StaticAnal$$anonfun$1$$anonfun$apply$3: apply(Ljava/lang/Object;) ===> StaticAnal.$anonfun.$anonfun: apply(token: Scanner.Token)
StaticAnal$$anonfun$1$$anonfun$apply$4: apply(Ljava/lang/Object;) ===> StaticAnal.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
StaticAnal$$anonfun$1: apply(Ljava/lang/Object;) ===> StaticAnal.$anonfun: apply(file: String)
StaticAnal$$anonfun$definiteAssignment$1$$anonfun$apply$2: apply(Ljava/lang/Object;) ===> StaticAnal.$anonfun.$anonfun: apply(x0$4: Ast.AstNode)
StaticAnal$$anonfun$definiteAssignment$1: apply(Ljava/lang/Object;) ===> StaticAnal.$anonfun: apply(x0$3: Ast.AstNode)
StaticAnal$$anonfun$main$1: apply(Ljava/lang/Object;) ===> StaticAnal.$anonfun: apply(x$1: Ast.AstNode)
StaticAnal$$anonfun$reachability$1$$anonfun$apply$1: apply(Ljava/lang/Object;) ===> StaticAnal.$anonfun.$anonfun: apply(x0$2: Ast.AstNode)
StaticAnal$$anonfun$reachability$1: apply(Ljava/lang/Object;) ===> StaticAnal.$anonfun: apply(x0$1: Ast.AstNode)
StaticAnal$: <clinit>() ===> StaticAnal: <init>()
StaticAnal.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.ArrayType: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.ImportClass: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.ImportStar: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.Name: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.RefType: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Names.ConstrSig: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Names.MethodSig: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Leaf: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Node: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Production: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Reduce: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Shift: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Scanner.Token: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(x0$4: Ast.AstNode) ===> Ast.ArrayType: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(x0$4: Ast.AstNode) ===> Ast.ImportClass: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(x0$4: Ast.AstNode) ===> Ast.ImportStar: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(x0$4: Ast.AstNode) ===> Ast.Name: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(x0$4: Ast.AstNode) ===> Ast.RefType: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(x0$4: Ast.AstNode) ===> Names.ConstrSig: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(x0$4: Ast.AstNode) ===> Names.MethodSig: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(x0$4: Ast.AstNode) ===> Parser.Leaf: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(x0$4: Ast.AstNode) ===> Parser.Node: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(x0$4: Ast.AstNode) ===> Parser.Production: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(x0$4: Ast.AstNode) ===> Parser.Reduce: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(x0$4: Ast.AstNode) ===> Parser.Shift: equals(x$1: Any)
StaticAnal.$anonfun.$anonfun: apply(x0$4: Ast.AstNode) ===> Scanner.Token: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Ast$ArraySpec: typ()
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Ast$BooleanSpec: typ()
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Ast$ByteSpec: typ()
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Ast$CharSpec: typ()
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Ast$IntSpec: typ()
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Ast$RefSpec: typ()
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Ast$ShortSpec: typ()
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Ast$VoidSpec: typ()
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Ast.ArrayType: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Ast.ImportClass: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Ast.ImportStar: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Ast.Name: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Ast.RefType: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Names.ConstrSig: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Names.MethodSig: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Parser.Leaf: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Parser.Node: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Parser.Production: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Parser.Reduce: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Parser.Shift: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$1: Ast.AstNode) ===> Scanner.Token: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$3: Ast.AstNode) ===> Ast.ArrayType: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$3: Ast.AstNode) ===> Ast.ImportClass: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$3: Ast.AstNode) ===> Ast.ImportStar: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$3: Ast.AstNode) ===> Ast.Name: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$3: Ast.AstNode) ===> Ast.RefType: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$3: Ast.AstNode) ===> Names.ConstrSig: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$3: Ast.AstNode) ===> Names.MethodSig: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$3: Ast.AstNode) ===> Parser.Leaf: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$3: Ast.AstNode) ===> Parser.Node: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$3: Ast.AstNode) ===> Parser.Production: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$3: Ast.AstNode) ===> Parser.Reduce: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$3: Ast.AstNode) ===> Parser.Shift: equals(x$1: Any)
StaticAnal.$anonfun: apply(x0$3: Ast.AstNode) ===> Scanner.Token: equals(x$1: Any)
StaticAnal: complete(s: Ast.Stmt) ===> Ast.ArrayType: equals(x$1: Any)
StaticAnal: complete(s: Ast.Stmt) ===> Ast.ImportClass: equals(x$1: Any)
StaticAnal: complete(s: Ast.Stmt) ===> Ast.ImportStar: equals(x$1: Any)
StaticAnal: complete(s: Ast.Stmt) ===> Ast.Name: equals(x$1: Any)
StaticAnal: complete(s: Ast.Stmt) ===> Ast.RefType: equals(x$1: Any)
StaticAnal: complete(s: Ast.Stmt) ===> Names.ConstrSig: equals(x$1: Any)
StaticAnal: complete(s: Ast.Stmt) ===> Names.MethodSig: equals(x$1: Any)
StaticAnal: complete(s: Ast.Stmt) ===> Parser.Leaf: equals(x$1: Any)
StaticAnal: complete(s: Ast.Stmt) ===> Parser.Node: equals(x$1: Any)
StaticAnal: complete(s: Ast.Stmt) ===> Parser.Production: equals(x$1: Any)
StaticAnal: complete(s: Ast.Stmt) ===> Parser.Reduce: equals(x$1: Any)
StaticAnal: complete(s: Ast.Stmt) ===> Parser.Shift: equals(x$1: Any)
StaticAnal: complete(s: Ast.Stmt) ===> Scanner.Token: equals(x$1: Any)
StaticAnal: fold(e: Ast.Expr) ===> Ast.ArrayType: equals(x$1: Any)
StaticAnal: fold(e: Ast.Expr) ===> Ast.ImportClass: equals(x$1: Any)
StaticAnal: fold(e: Ast.Expr) ===> Ast.ImportStar: equals(x$1: Any)
StaticAnal: fold(e: Ast.Expr) ===> Ast.Name: equals(x$1: Any)
StaticAnal: fold(e: Ast.Expr) ===> Ast.RefType: equals(x$1: Any)
StaticAnal: fold(e: Ast.Expr) ===> Names.ConstrSig: equals(x$1: Any)
StaticAnal: fold(e: Ast.Expr) ===> Names.MethodSig: equals(x$1: Any)
StaticAnal: fold(e: Ast.Expr) ===> Parser.Leaf: equals(x$1: Any)
StaticAnal: fold(e: Ast.Expr) ===> Parser.Node: equals(x$1: Any)
StaticAnal: fold(e: Ast.Expr) ===> Parser.Production: equals(x$1: Any)
StaticAnal: fold(e: Ast.Expr) ===> Parser.Reduce: equals(x$1: Any)
StaticAnal: fold(e: Ast.Expr) ===> Parser.Shift: equals(x$1: Any)
StaticAnal: fold(e: Ast.Expr) ===> Scanner.Token: equals(x$1: Any)
StaticAnal: helper(l: List[Ast.Stmt]) ===> Ast.ArrayType: equals(x$1: Any)
StaticAnal: helper(l: List[Ast.Stmt]) ===> Ast.ImportClass: equals(x$1: Any)
StaticAnal: helper(l: List[Ast.Stmt]) ===> Ast.ImportStar: equals(x$1: Any)
StaticAnal: helper(l: List[Ast.Stmt]) ===> Ast.Name: equals(x$1: Any)
StaticAnal: helper(l: List[Ast.Stmt]) ===> Ast.RefType: equals(x$1: Any)
StaticAnal: helper(l: List[Ast.Stmt]) ===> Names.ConstrSig: equals(x$1: Any)
StaticAnal: helper(l: List[Ast.Stmt]) ===> Names.MethodSig: equals(x$1: Any)
StaticAnal: helper(l: List[Ast.Stmt]) ===> Parser.Leaf: equals(x$1: Any)
StaticAnal: helper(l: List[Ast.Stmt]) ===> Parser.Node: equals(x$1: Any)
StaticAnal: helper(l: List[Ast.Stmt]) ===> Parser.Production: equals(x$1: Any)
StaticAnal: helper(l: List[Ast.Stmt]) ===> Parser.Reduce: equals(x$1: Any)
StaticAnal: helper(l: List[Ast.Stmt]) ===> Parser.Shift: equals(x$1: Any)
StaticAnal: helper(l: List[Ast.Stmt]) ===> Scanner.Token: equals(x$1: Any)
StaticAnal: main(args: Array[String]) ===> StaticAnal: main(args: Array[String])
StaticAnal: reach(s: Ast.Stmt) ===> Ast.ArrayType: equals(x$1: Any)
StaticAnal: reach(s: Ast.Stmt) ===> Ast.ImportClass: equals(x$1: Any)
StaticAnal: reach(s: Ast.Stmt) ===> Ast.ImportStar: equals(x$1: Any)
StaticAnal: reach(s: Ast.Stmt) ===> Ast.Name: equals(x$1: Any)
StaticAnal: reach(s: Ast.Stmt) ===> Ast.RefType: equals(x$1: Any)
StaticAnal: reach(s: Ast.Stmt) ===> Names.ConstrSig: equals(x$1: Any)
StaticAnal: reach(s: Ast.Stmt) ===> Names.MethodSig: equals(x$1: Any)
StaticAnal: reach(s: Ast.Stmt) ===> Parser.Leaf: equals(x$1: Any)
StaticAnal: reach(s: Ast.Stmt) ===> Parser.Node: equals(x$1: Any)
StaticAnal: reach(s: Ast.Stmt) ===> Parser.Production: equals(x$1: Any)
StaticAnal: reach(s: Ast.Stmt) ===> Parser.Reduce: equals(x$1: Any)
StaticAnal: reach(s: Ast.Stmt) ===> Parser.Shift: equals(x$1: Any)
StaticAnal: reach(s: Ast.Stmt) ===> Scanner.Token: equals(x$1: Any)
Types$$anonfun$1: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Types$$anonfun$1: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(n: Ast.AstNode)
Types$$anonfun$2: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Types$$anonfun$2: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(md: Ast.MethodDecl)
Types$$anonfun$3: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Types$$anonfun$3: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(md: Ast.MethodDecl)
Types$$anonfun$4: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(x$14: Ast.Expr)
Types$$anonfun$5: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Types$$anonfun$5: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(n: Ast.AstNode)
Types$$anonfun$6$$anonfun$apply$24: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun: apply(token: Scanner.Token)
Types$$anonfun$6$$anonfun$apply$25: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Types$$anonfun$6: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(file: String)
Types$$anonfun$checkAccess$1$1: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(x0$6: Ast.AstNode)
Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20$$anonfun$apply$21: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20$$anonfun$apply$21: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun.$anonfun: apply(constr: Ast.ConstructorDecl)
Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20$$anonfun$apply$22: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun.$anonfun: apply(constr: Ast.ConstructorDecl)
Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Types$$anonfun$checkConstructorNames$1$1: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(cu: Ast.CompUnit)
Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$15: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$15: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$17: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun.$anonfun: apply(constr: Ast.ConstructorDecl)
Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$18: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$18: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun.$anonfun: apply(x$15: Ast.ConstructorDecl, Ast.ClassDecl)
Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$19: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun.$anonfun: apply(x$16: Ast.ConstructorDecl, Ast.ClassDecl)
Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun: apply(cls: Ast.ClassDecl)
Types$$anonfun$checkConstructorSuperInvokes$1$1: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(cu: Ast.CompUnit)
Types$$anonfun$checkForwardReferences$1$1$$anonfun$apply$23: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun: apply(x0$8: Ast.AstNode)
Types$$anonfun$checkForwardReferences$1$1: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(x0$7: Ast.AstNode)
Types$$anonfun$checkTypes$1$1: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(x0$5: Ast.AstNode)
Types$$anonfun$disambiguation$1: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(x0$3: Ast.AstNode)
Types$$anonfun$disField$1$1: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Types$$anonfun$disField$1$1: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(i: Int)
Types$$anonfun$disField$1$2$$anonfun$apply$1: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun: apply(n: String)
Types$$anonfun$disField$1$2: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(ts: Ast.TypeSpec)
Types$$anonfun$disField$1$3$$anonfun$apply$2: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun: apply(n: String)
Types$$anonfun$disField$1$3: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(fd: Ast.FieldDecl)
Types$$anonfun$disField$1$4$$anonfun$apply$3$$anonfun$apply$4: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun.$anonfun: apply(n: String)
Types$$anonfun$disField$1$4$$anonfun$apply$3: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun: apply(cd: Ast.ClassDecl)
Types$$anonfun$disField$1$4: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Types$$anonfun$disField$1$4: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(i: Int)
Types$$anonfun$disField$1$5: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(x$2: Ast.AstNode)
Types$$anonfun$disField$1$6: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(x$3: Ast.AstNode)
Types$$anonfun$disInvoke$1$1: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(x0$2: Ast.AstNode)
Types$$anonfun$disLval$1$1$$anonfun$apply$10: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun: apply(x$8: Ast.Expr)
Types$$anonfun$disLval$1$1$$anonfun$apply$11: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun: apply(x$9: Ast.Expr)
Types$$anonfun$disLval$1$1$$anonfun$apply$12: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun: apply(x$10: Ast.Expr)
Types$$anonfun$disLval$1$1$$anonfun$apply$13: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun: apply(x$11: Ast.Expr)
Types$$anonfun$disLval$1$1$$anonfun$apply$14: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun: apply(x$12: Ast.Expr)
Types$$anonfun$disLval$1$1$$anonfun$apply$9: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun: apply(x$7: Ast.Expr)
Types$$anonfun$disLval$1$1: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(x0$1: Ast.AstNode)
Types$$anonfun$formalConf$1$1: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Types$$anonfun$formalConf$1$1: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(x0$4: Ast.Type, Ast.Expr)
Types$$anonfun$main$1: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(x$17: Ast.AstNode)
Types$$anonfun$stringClass$1$1: apply() ===> Types.$anonfun: apply()
Types$$anonfun$Types$$disMethod$1$1: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Types$$anonfun$Types$$disMethod$1$1: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(i: Int)
Types$$anonfun$Types$$disMethod$1$2$$anonfun$apply$5: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun: apply(n: String)
Types$$anonfun$Types$$disMethod$1$2: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(ts: Ast.TypeSpec)
Types$$anonfun$Types$$disMethod$1$3$$anonfun$apply$6: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun: apply(n: String)
Types$$anonfun$Types$$disMethod$1$3: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(fd: Ast.FieldDecl)
Types$$anonfun$Types$$disMethod$1$4$$anonfun$apply$7$$anonfun$apply$8: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun.$anonfun: apply(n: String)
Types$$anonfun$Types$$disMethod$1$4$$anonfun$apply$7: apply(Ljava/lang/Object;) ===> Types.$anonfun.$anonfun: apply(cd: Ast.ClassDecl)
Types$$anonfun$Types$$disMethod$1$4: apply(Ljava/lang/Object;) ===> ca.uwaterloo.scalacg.Library: blob()
Types$$anonfun$Types$$disMethod$1$4: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(i: Int)
Types$$anonfun$Types$$disMethod$1$5: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(x$5: Ast.AstNode)
Types$$anonfun$Types$$disMethod$1$6: apply(Ljava/lang/Object;) ===> Types.$anonfun: apply(x$6: Ast.AstNode)
Types$: <clinit>() ===> Types: <init>()
Types$: arrayLengthDecl$lzycompute() ===> Ast.FieldDecl: <init>(modifiers: scala.collection.immutable.Set[Ast.Modifier],ts: Ast.TypeSpec,name: String,init: Option[Ast.Expr])
Types$: arrayLengthDecl$lzycompute() ===> Ast.IntSpec: <init>()
Types$: arrayLengthDecl$lzycompute() ===> ca.uwaterloo.scalacg.Library: blob()
Types.$anonfun.$anonfun.$anonfun: apply(constr: Ast.ConstructorDecl) ===> Ast.ArrayType: equals(x$1: Any)
Types.$anonfun.$anonfun.$anonfun: apply(constr: Ast.ConstructorDecl) ===> Ast.ImportClass: equals(x$1: Any)
Types.$anonfun.$anonfun.$anonfun: apply(constr: Ast.ConstructorDecl) ===> Ast.ImportStar: equals(x$1: Any)
Types.$anonfun.$anonfun.$anonfun: apply(constr: Ast.ConstructorDecl) ===> Ast.Name: equals(x$1: Any)
Types.$anonfun.$anonfun.$anonfun: apply(constr: Ast.ConstructorDecl) ===> Ast.RefType: equals(x$1: Any)
Types.$anonfun.$anonfun.$anonfun: apply(constr: Ast.ConstructorDecl) ===> Names.ConstrSig: equals(x$1: Any)
Types.$anonfun.$anonfun.$anonfun: apply(constr: Ast.ConstructorDecl) ===> Names.MethodSig: equals(x$1: Any)
Types.$anonfun.$anonfun.$anonfun: apply(constr: Ast.ConstructorDecl) ===> Parser.Leaf: equals(x$1: Any)
Types.$anonfun.$anonfun.$anonfun: apply(constr: Ast.ConstructorDecl) ===> Parser.Node: equals(x$1: Any)
Types.$anonfun.$anonfun.$anonfun: apply(constr: Ast.ConstructorDecl) ===> Parser.Production: equals(x$1: Any)
Types.$anonfun.$anonfun.$anonfun: apply(constr: Ast.ConstructorDecl) ===> Parser.Reduce: equals(x$1: Any)
Types.$anonfun.$anonfun.$anonfun: apply(constr: Ast.ConstructorDecl) ===> Parser.Shift: equals(x$1: Any)
Types.$anonfun.$anonfun.$anonfun: apply(constr: Ast.ConstructorDecl) ===> Scanner.Token: equals(x$1: Any)
Types.$anonfun.$anonfun.$anonfun: apply(n: String) ===> Types$$anonfun$disField$1$4$$anonfun$apply$3: Types$$anonfun$$anonfun$$$outer()
Types.$anonfun.$anonfun.$anonfun: apply(n: String) ===> Types$$anonfun$Types$$disMethod$1$4$$anonfun$apply$7: Types$$anonfun$$anonfun$$$outer()
Types.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.ArrayType: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.ImportClass: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.ImportStar: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.Name: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Ast.RefType: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Names.ConstrSig: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Names.MethodSig: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Leaf: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Node: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Production: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Reduce: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Parser.Shift: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(cls: Ast.ClassDecl) ===> Scanner.Token: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(x0$8: Ast.AstNode) ===> Ast.ArrayType: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(x0$8: Ast.AstNode) ===> Ast.ImportClass: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(x0$8: Ast.AstNode) ===> Ast.ImportStar: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(x0$8: Ast.AstNode) ===> Ast.Name: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(x0$8: Ast.AstNode) ===> Ast.RefType: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(x0$8: Ast.AstNode) ===> Names.ConstrSig: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(x0$8: Ast.AstNode) ===> Names.MethodSig: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(x0$8: Ast.AstNode) ===> Parser.Leaf: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(x0$8: Ast.AstNode) ===> Parser.Node: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(x0$8: Ast.AstNode) ===> Parser.Production: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(x0$8: Ast.AstNode) ===> Parser.Reduce: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(x0$8: Ast.AstNode) ===> Parser.Shift: equals(x$1: Any)
Types.$anonfun.$anonfun: apply(x0$8: Ast.AstNode) ===> Scanner.Token: equals(x$1: Any)
Types.$anonfun.$anonfun: helper(stmts: List[Ast.MemberDecl]) ===> Ast.ArrayType: equals(x$1: Any)
Types.$anonfun.$anonfun: helper(stmts: List[Ast.MemberDecl]) ===> Ast.ImportClass: equals(x$1: Any)
Types.$anonfun.$anonfun: helper(stmts: List[Ast.MemberDecl]) ===> Ast.ImportStar: equals(x$1: Any)
Types.$anonfun.$anonfun: helper(stmts: List[Ast.MemberDecl]) ===> Ast.Name: equals(x$1: Any)
Types.$anonfun.$anonfun: helper(stmts: List[Ast.MemberDecl]) ===> Ast.RefType: equals(x$1: Any)
Types.$anonfun.$anonfun: helper(stmts: List[Ast.MemberDecl]) ===> Names.ConstrSig: equals(x$1: Any)
Types.$anonfun.$anonfun: helper(stmts: List[Ast.MemberDecl]) ===> Names.MethodSig: equals(x$1: Any)
Types.$anonfun.$anonfun: helper(stmts: List[Ast.MemberDecl]) ===> Parser.Leaf: equals(x$1: Any)
Types.$anonfun.$anonfun: helper(stmts: List[Ast.MemberDecl]) ===> Parser.Node: equals(x$1: Any)
Types.$anonfun.$anonfun: helper(stmts: List[Ast.MemberDecl]) ===> Parser.Production: equals(x$1: Any)
Types.$anonfun.$anonfun: helper(stmts: List[Ast.MemberDecl]) ===> Parser.Reduce: equals(x$1: Any)
Types.$anonfun.$anonfun: helper(stmts: List[Ast.MemberDecl]) ===> Parser.Shift: equals(x$1: Any)
Types.$anonfun.$anonfun: helper(stmts: List[Ast.MemberDecl]) ===> Scanner.Token: equals(x$1: Any)
Types.$anonfun: apply(i: Int) ===> Types$$anonfun$disField$1$1: apply$mcZI$sp(I)
Types.$anonfun: apply(i: Int) ===> Types$$anonfun$Types$$disMethod$1$1: apply$mcZI$sp(I)
Types.$anonfun: apply(x0$2: Ast.AstNode) ===> Ast.ArrayType: equals(x$1: Any)
Types.$anonfun: apply(x0$2: Ast.AstNode) ===> Ast.ImportClass: equals(x$1: Any)
Types.$anonfun: apply(x0$2: Ast.AstNode) ===> Ast.ImportStar: equals(x$1: Any)
Types.$anonfun: apply(x0$2: Ast.AstNode) ===> Ast.Name: equals(x$1: Any)
Types.$anonfun: apply(x0$2: Ast.AstNode) ===> Ast.RefType: equals(x$1: Any)
Types.$anonfun: apply(x0$2: Ast.AstNode) ===> Names.ConstrSig: equals(x$1: Any)
Types.$anonfun: apply(x0$2: Ast.AstNode) ===> Names.MethodSig: equals(x$1: Any)
Types.$anonfun: apply(x0$2: Ast.AstNode) ===> Parser.Leaf: equals(x$1: Any)
Types.$anonfun: apply(x0$2: Ast.AstNode) ===> Parser.Node: equals(x$1: Any)
Types.$anonfun: apply(x0$2: Ast.AstNode) ===> Parser.Production: equals(x$1: Any)
Types.$anonfun: apply(x0$2: Ast.AstNode) ===> Parser.Reduce: equals(x$1: Any)
Types.$anonfun: apply(x0$2: Ast.AstNode) ===> Parser.Shift: equals(x$1: Any)
Types.$anonfun: apply(x0$2: Ast.AstNode) ===> Scanner.Token: equals(x$1: Any)
Types.$anonfun: apply(x0$4: Ast.Type, Ast.Expr) ===> Ast.ArrayType: equals(x$1: Any)
Types.$anonfun: apply(x0$4: Ast.Type, Ast.Expr) ===> Ast.ImportClass: equals(x$1: Any)
Types.$anonfun: apply(x0$4: Ast.Type, Ast.Expr) ===> Ast.ImportStar: equals(x$1: Any)
Types.$anonfun: apply(x0$4: Ast.Type, Ast.Expr) ===> Ast.Name: equals(x$1: Any)
Types.$anonfun: apply(x0$4: Ast.Type, Ast.Expr) ===> Ast.RefType: equals(x$1: Any)
Types.$anonfun: apply(x0$4: Ast.Type, Ast.Expr) ===> Names.ConstrSig: equals(x$1: Any)
Types.$anonfun: apply(x0$4: Ast.Type, Ast.Expr) ===> Names.MethodSig: equals(x$1: Any)
Types.$anonfun: apply(x0$4: Ast.Type, Ast.Expr) ===> Parser.Leaf: equals(x$1: Any)
Types.$anonfun: apply(x0$4: Ast.Type, Ast.Expr) ===> Parser.Node: equals(x$1: Any)
Types.$anonfun: apply(x0$4: Ast.Type, Ast.Expr) ===> Parser.Production: equals(x$1: Any)
Types.$anonfun: apply(x0$4: Ast.Type, Ast.Expr) ===> Parser.Reduce: equals(x$1: Any)
Types.$anonfun: apply(x0$4: Ast.Type, Ast.Expr) ===> Parser.Shift: equals(x$1: Any)
Types.$anonfun: apply(x0$4: Ast.Type, Ast.Expr) ===> Scanner.Token: equals(x$1: Any)
Types.$anonfun: apply(x0$6: Ast.AstNode) ===> Ast.ArrayType: equals(x$1: Any)
Types.$anonfun: apply(x0$6: Ast.AstNode) ===> Ast.ImportClass: equals(x$1: Any)
Types.$anonfun: apply(x0$6: Ast.AstNode) ===> Ast.ImportStar: equals(x$1: Any)
Types.$anonfun: apply(x0$6: Ast.AstNode) ===> Ast.Name: equals(x$1: Any)
Types.$anonfun: apply(x0$6: Ast.AstNode) ===> Ast.RefType: equals(x$1: Any)
Types.$anonfun: apply(x0$6: Ast.AstNode) ===> Names.ConstrSig: equals(x$1: Any)
Types.$anonfun: apply(x0$6: Ast.AstNode) ===> Names.MethodSig: equals(x$1: Any)
Types.$anonfun: apply(x0$6: Ast.AstNode) ===> Parser.Leaf: equals(x$1: Any)
Types.$anonfun: apply(x0$6: Ast.AstNode) ===> Parser.Node: equals(x$1: Any)
Types.$anonfun: apply(x0$6: Ast.AstNode) ===> Parser.Production: equals(x$1: Any)
Types.$anonfun: apply(x0$6: Ast.AstNode) ===> Parser.Reduce: equals(x$1: Any)
Types.$anonfun: apply(x0$6: Ast.AstNode) ===> Parser.Shift: equals(x$1: Any)
Types.$anonfun: apply(x0$6: Ast.AstNode) ===> Scanner.Token: equals(x$1: Any)
Types: allowed(mods: scala.collection.immutable.Set[Ast.Modifier],declCls: Ast.ClassDecl,exprCls: Ast.ClassDecl,calledOnCls: Ast.ClassDecl) ===> Ast.ArrayType: equals(x$1: Any)
Types: allowed(mods: scala.collection.immutable.Set[Ast.Modifier],declCls: Ast.ClassDecl,exprCls: Ast.ClassDecl,calledOnCls: Ast.ClassDecl) ===> Ast.ImportClass: equals(x$1: Any)
Types: allowed(mods: scala.collection.immutable.Set[Ast.Modifier],declCls: Ast.ClassDecl,exprCls: Ast.ClassDecl,calledOnCls: Ast.ClassDecl) ===> Ast.ImportStar: equals(x$1: Any)
Types: allowed(mods: scala.collection.immutable.Set[Ast.Modifier],declCls: Ast.ClassDecl,exprCls: Ast.ClassDecl,calledOnCls: Ast.ClassDecl) ===> Ast.Name: equals(x$1: Any)
Types: allowed(mods: scala.collection.immutable.Set[Ast.Modifier],declCls: Ast.ClassDecl,exprCls: Ast.ClassDecl,calledOnCls: Ast.ClassDecl) ===> Ast.RefType: equals(x$1: Any)
Types: allowed(mods: scala.collection.immutable.Set[Ast.Modifier],declCls: Ast.ClassDecl,exprCls: Ast.ClassDecl,calledOnCls: Ast.ClassDecl) ===> Names.ConstrSig: equals(x$1: Any)
Types: allowed(mods: scala.collection.immutable.Set[Ast.Modifier],declCls: Ast.ClassDecl,exprCls: Ast.ClassDecl,calledOnCls: Ast.ClassDecl) ===> Names.MethodSig: equals(x$1: Any)
Types: allowed(mods: scala.collection.immutable.Set[Ast.Modifier],declCls: Ast.ClassDecl,exprCls: Ast.ClassDecl,calledOnCls: Ast.ClassDecl) ===> Parser.Leaf: equals(x$1: Any)
Types: allowed(mods: scala.collection.immutable.Set[Ast.Modifier],declCls: Ast.ClassDecl,exprCls: Ast.ClassDecl,calledOnCls: Ast.ClassDecl) ===> Parser.Node: equals(x$1: Any)
Types: allowed(mods: scala.collection.immutable.Set[Ast.Modifier],declCls: Ast.ClassDecl,exprCls: Ast.ClassDecl,calledOnCls: Ast.ClassDecl) ===> Parser.Production: equals(x$1: Any)
Types: allowed(mods: scala.collection.immutable.Set[Ast.Modifier],declCls: Ast.ClassDecl,exprCls: Ast.ClassDecl,calledOnCls: Ast.ClassDecl) ===> Parser.Reduce: equals(x$1: Any)
Types: allowed(mods: scala.collection.immutable.Set[Ast.Modifier],declCls: Ast.ClassDecl,exprCls: Ast.ClassDecl,calledOnCls: Ast.ClassDecl) ===> Parser.Shift: equals(x$1: Any)
Types: allowed(mods: scala.collection.immutable.Set[Ast.Modifier],declCls: Ast.ClassDecl,exprCls: Ast.ClassDecl,calledOnCls: Ast.ClassDecl) ===> Scanner.Token: equals(x$1: Any)
Types: arrayLengthDecl() ===> Types$: arrayLengthDecl$lzycompute()
Types: assignable(dst: Ast.Type,src: Ast.Type) ===> Ast.ArrayType: equals(x$1: Any)
Types: assignable(dst: Ast.Type,src: Ast.Type) ===> Ast.ImportClass: equals(x$1: Any)
Types: assignable(dst: Ast.Type,src: Ast.Type) ===> Ast.ImportStar: equals(x$1: Any)
Types: assignable(dst: Ast.Type,src: Ast.Type) ===> Ast.Name: equals(x$1: Any)
Types: assignable(dst: Ast.Type,src: Ast.Type) ===> Ast.RefType: equals(x$1: Any)
Types: assignable(dst: Ast.Type,src: Ast.Type) ===> Names.ConstrSig: equals(x$1: Any)
Types: assignable(dst: Ast.Type,src: Ast.Type) ===> Names.MethodSig: equals(x$1: Any)
Types: assignable(dst: Ast.Type,src: Ast.Type) ===> Parser.Leaf: equals(x$1: Any)
Types: assignable(dst: Ast.Type,src: Ast.Type) ===> Parser.Node: equals(x$1: Any)
Types: assignable(dst: Ast.Type,src: Ast.Type) ===> Parser.Production: equals(x$1: Any)
Types: assignable(dst: Ast.Type,src: Ast.Type) ===> Parser.Reduce: equals(x$1: Any)
Types: assignable(dst: Ast.Type,src: Ast.Type) ===> Parser.Shift: equals(x$1: Any)
Types: assignable(dst: Ast.Type,src: Ast.Type) ===> Scanner.Token: equals(x$1: Any)
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Ast$ArraySpec: typ()
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Ast$BooleanSpec: typ()
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Ast$ByteSpec: typ()
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Ast$CharSpec: typ()
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Ast$IntSpec: typ()
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Ast$RefSpec: typ()
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Ast$ShortSpec: typ()
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Ast$VoidSpec: typ()
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Ast.ArrayType: equals(x$1: Any)
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Ast.ImportClass: equals(x$1: Any)
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Ast.ImportStar: equals(x$1: Any)
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Ast.Name: equals(x$1: Any)
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Ast.RefType: equals(x$1: Any)
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Names.ConstrSig: equals(x$1: Any)
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Names.MethodSig: equals(x$1: Any)
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Parser.Leaf: equals(x$1: Any)
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Parser.Node: equals(x$1: Any)
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Parser.Production: equals(x$1: Any)
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Parser.Reduce: equals(x$1: Any)
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Parser.Shift: equals(x$1: Any)
Types: checkInit(ts: Ast.TypeSpec,init: Option[Ast.Expr]) ===> Scanner.Token: equals(x$1: Any)
Types: conforms(sig: Names.MethodSig,ie: Ast.InvokeExpr) ===> Ast.ArrayType: equals(x$1: Any)
Types: conforms(sig: Names.MethodSig,ie: Ast.InvokeExpr) ===> Ast.ImportClass: equals(x$1: Any)
Types: conforms(sig: Names.MethodSig,ie: Ast.InvokeExpr) ===> Ast.ImportStar: equals(x$1: Any)
Types: conforms(sig: Names.MethodSig,ie: Ast.InvokeExpr) ===> Ast.Name: equals(x$1: Any)
Types: conforms(sig: Names.MethodSig,ie: Ast.InvokeExpr) ===> Ast.RefType: equals(x$1: Any)
Types: conforms(sig: Names.MethodSig,ie: Ast.InvokeExpr) ===> Names.ConstrSig: equals(x$1: Any)
Types: conforms(sig: Names.MethodSig,ie: Ast.InvokeExpr) ===> Names.MethodSig: equals(x$1: Any)
Types: conforms(sig: Names.MethodSig,ie: Ast.InvokeExpr) ===> Parser.Leaf: equals(x$1: Any)
Types: conforms(sig: Names.MethodSig,ie: Ast.InvokeExpr) ===> Parser.Node: equals(x$1: Any)
Types: conforms(sig: Names.MethodSig,ie: Ast.InvokeExpr) ===> Parser.Production: equals(x$1: Any)
Types: conforms(sig: Names.MethodSig,ie: Ast.InvokeExpr) ===> Parser.Reduce: equals(x$1: Any)
Types: conforms(sig: Names.MethodSig,ie: Ast.InvokeExpr) ===> Parser.Shift: equals(x$1: Any)
Types: conforms(sig: Names.MethodSig,ie: Ast.InvokeExpr) ===> Scanner.Token: equals(x$1: Any)
Types: isArrayInterface(cd: Ast.ClassDecl) ===> Ast.ArrayType: equals(x$1: Any)
Types: isArrayInterface(cd: Ast.ClassDecl) ===> Ast.ImportClass: equals(x$1: Any)
Types: isArrayInterface(cd: Ast.ClassDecl) ===> Ast.ImportStar: equals(x$1: Any)
Types: isArrayInterface(cd: Ast.ClassDecl) ===> Ast.Name: equals(x$1: Any)
Types: isArrayInterface(cd: Ast.ClassDecl) ===> Ast.RefType: equals(x$1: Any)
Types: isArrayInterface(cd: Ast.ClassDecl) ===> Names.ConstrSig: equals(x$1: Any)
Types: isArrayInterface(cd: Ast.ClassDecl) ===> Names.MethodSig: equals(x$1: Any)
Types: isArrayInterface(cd: Ast.ClassDecl) ===> Parser.Leaf: equals(x$1: Any)
Types: isArrayInterface(cd: Ast.ClassDecl) ===> Parser.Node: equals(x$1: Any)
Types: isArrayInterface(cd: Ast.ClassDecl) ===> Parser.Production: equals(x$1: Any)
Types: isArrayInterface(cd: Ast.ClassDecl) ===> Parser.Reduce: equals(x$1: Any)
Types: isArrayInterface(cd: Ast.ClassDecl) ===> Parser.Shift: equals(x$1: Any)
Types: isArrayInterface(cd: Ast.ClassDecl) ===> Scanner.Token: equals(x$1: Any)
Types: isSubClass(sub: Ast.ClassDecl,sup: Ast.ClassDecl) ===> Ast.ArrayType: equals(x$1: Any)
Types: isSubClass(sub: Ast.ClassDecl,sup: Ast.ClassDecl) ===> Ast.ImportClass: equals(x$1: Any)
Types: isSubClass(sub: Ast.ClassDecl,sup: Ast.ClassDecl) ===> Ast.ImportStar: equals(x$1: Any)
Types: isSubClass(sub: Ast.ClassDecl,sup: Ast.ClassDecl) ===> Ast.Name: equals(x$1: Any)
Types: isSubClass(sub: Ast.ClassDecl,sup: Ast.ClassDecl) ===> Ast.RefType: equals(x$1: Any)
Types: isSubClass(sub: Ast.ClassDecl,sup: Ast.ClassDecl) ===> Names.ConstrSig: equals(x$1: Any)
Types: isSubClass(sub: Ast.ClassDecl,sup: Ast.ClassDecl) ===> Names.MethodSig: equals(x$1: Any)
Types: isSubClass(sub: Ast.ClassDecl,sup: Ast.ClassDecl) ===> Parser.Leaf: equals(x$1: Any)
Types: isSubClass(sub: Ast.ClassDecl,sup: Ast.ClassDecl) ===> Parser.Node: equals(x$1: Any)
Types: isSubClass(sub: Ast.ClassDecl,sup: Ast.ClassDecl) ===> Parser.Production: equals(x$1: Any)
Types: isSubClass(sub: Ast.ClassDecl,sup: Ast.ClassDecl) ===> Parser.Reduce: equals(x$1: Any)
Types: isSubClass(sub: Ast.ClassDecl,sup: Ast.ClassDecl) ===> Parser.Shift: equals(x$1: Any)
Types: isSubClass(sub: Ast.ClassDecl,sup: Ast.ClassDecl) ===> Scanner.Token: equals(x$1: Any)
Types: main(args: Array[String]) ===> Types: main(args: Array[String])
Types: typeCheck(e: Ast.Expr) ===> Ast$ArraySpec: typ()
Types: typeCheck(e: Ast.Expr) ===> Ast$BooleanSpec: typ()
Types: typeCheck(e: Ast.Expr) ===> Ast$ByteSpec: typ()
Types: typeCheck(e: Ast.Expr) ===> Ast$CharSpec: typ()
Types: typeCheck(e: Ast.Expr) ===> Ast$IntSpec: typ()
Types: typeCheck(e: Ast.Expr) ===> Ast$RefSpec: typ()
Types: typeCheck(e: Ast.Expr) ===> Ast$ShortSpec: typ()
Types: typeCheck(e: Ast.Expr) ===> Ast$VoidSpec: typ()
Types: typeCheck(e: Ast.Expr) ===> Ast.ArrayType: equals(x$1: Any)
Types: typeCheck(e: Ast.Expr) ===> Ast.ImportClass: equals(x$1: Any)
Types: typeCheck(e: Ast.Expr) ===> Ast.ImportStar: equals(x$1: Any)
Types: typeCheck(e: Ast.Expr) ===> Ast.Name: equals(x$1: Any)
Types: typeCheck(e: Ast.Expr) ===> Ast.RefType: equals(x$1: Any)
Types: typeCheck(e: Ast.Expr) ===> Names.ConstrSig: equals(x$1: Any)
Types: typeCheck(e: Ast.Expr) ===> Names.MethodSig: equals(x$1: Any)
Types: typeCheck(e: Ast.Expr) ===> Parser.Leaf: equals(x$1: Any)
Types: typeCheck(e: Ast.Expr) ===> Parser.Node: equals(x$1: Any)
Types: typeCheck(e: Ast.Expr) ===> Parser.Production: equals(x$1: Any)
Types: typeCheck(e: Ast.Expr) ===> Parser.Reduce: equals(x$1: Any)
Types: typeCheck(e: Ast.Expr) ===> Parser.Shift: equals(x$1: Any)
Types: typeCheck(e: Ast.Expr) ===> Scanner.Token: equals(x$1: Any)
Types: typeCheckStmt(s: Ast.Stmt) ===> Ast$ArraySpec: typ()
Types: typeCheckStmt(s: Ast.Stmt) ===> Ast$BooleanSpec: typ()
Types: typeCheckStmt(s: Ast.Stmt) ===> Ast$ByteSpec: typ()
Types: typeCheckStmt(s: Ast.Stmt) ===> Ast$CharSpec: typ()
Types: typeCheckStmt(s: Ast.Stmt) ===> Ast$IntSpec: typ()
Types: typeCheckStmt(s: Ast.Stmt) ===> Ast$RefSpec: typ()
Types: typeCheckStmt(s: Ast.Stmt) ===> Ast$ShortSpec: typ()
Types: typeCheckStmt(s: Ast.Stmt) ===> Ast$VoidSpec: typ()
Types: typeCheckStmt(s: Ast.Stmt) ===> Ast.ArrayType: equals(x$1: Any)
Types: typeCheckStmt(s: Ast.Stmt) ===> Ast.ImportClass: equals(x$1: Any)
Types: typeCheckStmt(s: Ast.Stmt) ===> Ast.ImportStar: equals(x$1: Any)
Types: typeCheckStmt(s: Ast.Stmt) ===> Ast.Name: equals(x$1: Any)
Types: typeCheckStmt(s: Ast.Stmt) ===> Ast.RefType: equals(x$1: Any)
Types: typeCheckStmt(s: Ast.Stmt) ===> Names.ConstrSig: equals(x$1: Any)
Types: typeCheckStmt(s: Ast.Stmt) ===> Names.MethodSig: equals(x$1: Any)
Types: typeCheckStmt(s: Ast.Stmt) ===> Parser.Leaf: equals(x$1: Any)
Types: typeCheckStmt(s: Ast.Stmt) ===> Parser.Node: equals(x$1: Any)
Types: typeCheckStmt(s: Ast.Stmt) ===> Parser.Production: equals(x$1: Any)
Types: typeCheckStmt(s: Ast.Stmt) ===> Parser.Reduce: equals(x$1: Any)
Types: typeCheckStmt(s: Ast.Stmt) ===> Parser.Shift: equals(x$1: Any)
Types: typeCheckStmt(s: Ast.Stmt) ===> Scanner.Token: equals(x$1: Any)
Util$$anonfun$closure$1: apply(Ljava/lang/Object;) ===> Util.$anonfun: apply(as: scala.collection.immutable.Set[A])
Util$: <clinit>() ===> Util: <init>()
Util$Memoize: toString() ===> ca.uwaterloo.scalacg.Library: blob()
Util.Memoize.$anonfun: apply() ===> Ast$$anonfun$assertAllLinks$1$$anonfun$apply$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Ast$$anonfun$assertAllLinks$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Ast$$anonfun$assertLinks$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Ast$$anonfun$assertLinks$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Ast$$anonfun$ast_CastExpression$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Ast$$anonfun$ast_ClassDeclaration$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Ast$$anonfun$dfs$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Ast$$anonfun$expandEscapes$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Ast$$anonfun$main$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Ast$$anonfun$main$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Ast$AstNode$$anonfun$linkParents$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Ast$ConstructorDecl$$anonfun$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Ast$MethodDecl$$anonfun$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anon$2$$anonfun$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anon$3$$anonfun$8: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anon$3$$anonfun$code$4: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anon$4$$anonfun$code$5: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$7: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$9$$anonfun$apply$21: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$9$$anonfun$apply$22: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$9: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$arrayFrame$lzycompute$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$classFrame$lzycompute$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$3: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$4: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$5: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$15$$anonfun$apply$16: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$15: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$17: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$18: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$19$$anonfun$apply$20: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$19: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$6: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$13: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$10: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$11$$anonfun$apply$12: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$11: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$3: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$4: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$3: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$codeGen$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$constFrame$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$constFrame$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$constrSig$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$main$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$mainClass$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$makeFrame$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$makeFrame$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$methodFrame$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$methodFrame$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$methodSig$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$objectFrame$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$objectFrame$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$$anonfun$objectFrame$3: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$2$$anonfun$apply$3: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$interfaceInvoke$2$$anonfun$3: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$4: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$5: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$6: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$interfaceInvoke$2$$anonfun$code$3: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$subtypeTests$2$$anonfun$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$subtypeTests$2$$anonfun$code$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> CodeGen$subtypeTests$2$$anonfun$code$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> MakeAst$$anonfun$main$1$$anonfun$apply$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> MakeAst$$anonfun$main$1$$anonfun$apply$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> MakeAst$$anonfun$main$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$10: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$12$$anonfun$apply$76: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$12$$anonfun$apply$77: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$12: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$8: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$9: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$32: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$34: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$36: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$37: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$38: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addAbstractObjectMethods$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$39: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$40: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$11: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$43: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$44: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$45: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$46: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addAbstractObjectMethods$1$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addClasses$1$1$$anonfun$apply$5: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$addClasses$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$canonicalNames$1$1$$anonfun$apply$4: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$canonicalNames$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20$$anonfun$apply$21$$anonfun$apply$22: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20$$anonfun$apply$21: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkDemandPackageIsClass$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkHierarchyCycles$1$1$$anonfun$apply$31: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkHierarchyCycles$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$28: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$29$$anonfun$apply$30: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$29: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkInterfaceFields$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17$$anonfun$apply$18$$anonfun$apply$19: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17$$anonfun$apply$18: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkNonExistingPackage$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkPackageClashWithType$1$1$$anonfun$apply$25: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkPackageClashWithType$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkPrefixesOfReferences$1$1$$anonfun$apply$26: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkPrefixesOfReferences$1$1$$anonfun$apply$27: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkPrefixesOfReferences$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkSingleTypeImports$1$1$$anonfun$apply$15$$anonfun$apply$16: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkSingleTypeImports$1$1$$anonfun$apply$15: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$checkSingleTypeImports$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$demandImports$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$demImp$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$demImp$1$2$$anonfun$apply$23: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$demImp$1$2$$anonfun$apply$24: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$demImp$1$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$enclosingBlock$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$enclosingClass$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$environments$1$$anonfun$apply$14: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$environments$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$63: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$64: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$66: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$67: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$68: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$69: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$70: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$71: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$73: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$74: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$75: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$hierarchy$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$interfaces$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$isSubtype$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$main$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$makeEnvs$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$10: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$11: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$12$$anonfun$apply$13: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$12: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$6: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$7: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$8$$anonfun$apply$9: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$8: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$Names$$addMembers$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$Names$$dfs$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$resolveTypes$1$1$$anonfun$7: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$resolveTypes$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$singleImports$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$$anonfun$typeLinking$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$ConstrSig$$anonfun$apply$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$Env$$anonfun$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$Env$$anonfun$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$Env$$anonfun$4$$anonfun$apply$3: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$Env$$anonfun$5: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$Env$$anonfun$lookupClass$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$Env$$anonfun$Names$Env$$tryName$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$Env$$anonfun$resolveClass$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$FieldCheck$$anonfun$declare$3: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$FieldCheck$$anonfun$declare$4: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$FieldCheck$$anonfun$inherit$2$$anonfun$apply$61: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$FieldCheck$$anonfun$inherit$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$allabs$1$$anonfun$apply$47: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$allabs$1$$anonfun$apply$48: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$allabs$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$declare$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$declare$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$49: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$50: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$51: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$inherit$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$nodecl$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$replace$1$$anonfun$apply$53: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$replace$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$56: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$57: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$58: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$59: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$60: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$replace$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$replaceM$1$$anonfun$apply$52: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodCheck$$anonfun$replaceM$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Names$MethodSig$$anonfun$apply$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Parser$$anon$1$$anonfun$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Parser$$anon$1$$anonfun$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Parser$$anonfun$main$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Parser$$anonfun$parse$1$$anonfun$go$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Parser$$anonfun$parse$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Parser$$anonfun$Parser$$nlines$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Parser$Node$$anonfun$toString$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Scanner$$anonfun$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Scanner$$anonfun$main$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Scanner$$anonfun$maximalmunch$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Scanner$$anonfun$maximalmunch$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> StaticAnal$$anonfun$1$$anonfun$apply$3: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> StaticAnal$$anonfun$1$$anonfun$apply$4: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> StaticAnal$$anonfun$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> StaticAnal$$anonfun$definiteAssignment$1$$anonfun$apply$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> StaticAnal$$anonfun$definiteAssignment$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> StaticAnal$$anonfun$main$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> StaticAnal$$anonfun$reachability$1$$anonfun$apply$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> StaticAnal$$anonfun$reachability$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$3: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$4: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$5: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$6$$anonfun$apply$24: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$6$$anonfun$apply$25: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$6: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$checkAccess$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20$$anonfun$apply$21: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20$$anonfun$apply$22: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$checkConstructorNames$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$15: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$17: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$18: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$19: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$checkConstructorSuperInvokes$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$checkForwardReferences$1$1$$anonfun$apply$23: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$checkForwardReferences$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$checkTypes$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disambiguation$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disField$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disField$1$2$$anonfun$apply$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disField$1$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disField$1$3$$anonfun$apply$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disField$1$3: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disField$1$4$$anonfun$apply$3$$anonfun$apply$4: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disField$1$4$$anonfun$apply$3: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disField$1$4: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disField$1$5: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disField$1$6: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disInvoke$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disLval$1$1$$anonfun$apply$10: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disLval$1$1$$anonfun$apply$11: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disLval$1$1$$anonfun$apply$12: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disLval$1$1$$anonfun$apply$13: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disLval$1$1$$anonfun$apply$14: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disLval$1$1$$anonfun$apply$9: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$disLval$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$formalConf$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$main$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$Types$$disMethod$1$1: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$Types$$disMethod$1$2$$anonfun$apply$5: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$Types$$disMethod$1$2: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$Types$$disMethod$1$3$$anonfun$apply$6: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$Types$$disMethod$1$3: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$Types$$disMethod$1$4$$anonfun$apply$7$$anonfun$apply$8: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$Types$$disMethod$1$4$$anonfun$apply$7: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$Types$$disMethod$1$4: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$Types$$disMethod$1$5: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Types$$anonfun$Types$$disMethod$1$6: apply(Ljava/lang/Object;)
Util.Memoize.$anonfun: apply() ===> Util$$anonfun$closure$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Ast$$anonfun$assertAllLinks$1$$anonfun$apply$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Ast$$anonfun$assertAllLinks$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Ast$$anonfun$assertLinks$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Ast$$anonfun$assertLinks$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Ast$$anonfun$ast_CastExpression$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Ast$$anonfun$ast_ClassDeclaration$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Ast$$anonfun$dfs$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Ast$$anonfun$expandEscapes$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Ast$$anonfun$main$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Ast$$anonfun$main$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Ast$AstNode$$anonfun$linkParents$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Ast$ConstructorDecl$$anonfun$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Ast$MethodDecl$$anonfun$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anon$2$$anonfun$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anon$3$$anonfun$8: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anon$3$$anonfun$code$4: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anon$4$$anonfun$code$5: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$7: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$9$$anonfun$apply$21: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$9$$anonfun$apply$22: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$9: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$arrayFrame$lzycompute$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$classFrame$lzycompute$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$3: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$4: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$CodeGen$$classFrameImpl$1$5: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$15$$anonfun$apply$16: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$15: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14$$anonfun$apply$17: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$14: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$18: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$19$$anonfun$apply$20: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$19: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$6: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$13: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$10: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$11$$anonfun$apply$12: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9$$anonfun$apply$11: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8$$anonfun$apply$9: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7$$anonfun$apply$8: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$$anonfun$apply$7: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$3: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genExpr$4: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5$generators$1$$anonfun$genStmt$3: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1$$anonfun$apply$5: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$codeGen$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$constFrame$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$constFrame$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$constrSig$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$main$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$mainClass$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$makeFrame$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$makeFrame$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$methodFrame$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$methodFrame$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$methodSig$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$objectFrame$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$objectFrame$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$$anonfun$objectFrame$3: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$2$$anonfun$apply$3: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$interfaceInvoke$2$$anonfun$3$$anonfun$apply$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$interfaceInvoke$2$$anonfun$3: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$4: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$5: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$interfaceInvoke$2$$anonfun$code$3$$anonfun$6: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$interfaceInvoke$2$$anonfun$code$3: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$subtypeTests$2$$anonfun$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$subtypeTests$2$$anonfun$code$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> CodeGen$subtypeTests$2$$anonfun$code$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> MakeAst$$anonfun$main$1$$anonfun$apply$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> MakeAst$$anonfun$main$1$$anonfun$apply$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> MakeAst$$anonfun$main$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$10: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$12$$anonfun$apply$76: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$12$$anonfun$apply$77: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$12: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$8: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$9: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$32: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$34: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$36: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$37: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35$$anonfun$apply$38: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33$$anonfun$apply$35: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addAbstractObjectMethods$1$1$$anonfun$apply$33: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addAbstractObjectMethods$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$39: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$40: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$11: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$43: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$44: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$45: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42$$anonfun$apply$46: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41$$anonfun$apply$42: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addAbstractObjectMethods$1$2$$anonfun$apply$41: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addAbstractObjectMethods$1$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addClasses$1$1$$anonfun$apply$5: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$addClasses$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$canonicalNames$1$1$$anonfun$apply$4: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$canonicalNames$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20$$anonfun$apply$21$$anonfun$apply$22: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20$$anonfun$apply$21: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkDemandPackageIsClass$1$1$$anonfun$apply$20: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkDemandPackageIsClass$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkHierarchyCycles$1$1$$anonfun$apply$31: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkHierarchyCycles$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$28: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$29$$anonfun$apply$30: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkInterfaceFields$1$1$$anonfun$apply$29: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkInterfaceFields$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17$$anonfun$apply$18$$anonfun$apply$19: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17$$anonfun$apply$18: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkNonExistingPackage$1$1$$anonfun$apply$17: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkNonExistingPackage$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkPackageClashWithType$1$1$$anonfun$apply$25: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkPackageClashWithType$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkPrefixesOfReferences$1$1$$anonfun$apply$26: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkPrefixesOfReferences$1$1$$anonfun$apply$27: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkPrefixesOfReferences$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkSingleTypeImports$1$1$$anonfun$apply$15$$anonfun$apply$16: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkSingleTypeImports$1$1$$anonfun$apply$15: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$checkSingleTypeImports$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$demandImports$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$demImp$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$demImp$1$2$$anonfun$apply$23: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$demImp$1$2$$anonfun$apply$24: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$demImp$1$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$enclosingBlock$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$enclosingClass$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$environments$1$$anonfun$apply$14: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$environments$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$63: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$64: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$66: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$67: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65$$anonfun$apply$68: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$65: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$69: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$70: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$71: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$73: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$74: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72$$anonfun$apply$75: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62$$anonfun$apply$72: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$hierarchy$1$$anonfun$apply$62: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$hierarchy$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$interfaces$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$isSubtype$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$main$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$makeEnvs$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$10: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$11: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$12$$anonfun$apply$13: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$12: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$6: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$7: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$8$$anonfun$apply$9: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$Names$$addMembers$1$1$$anonfun$apply$8: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$Names$$addMembers$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$Names$$dfs$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$resolveTypes$1$1$$anonfun$7: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$resolveTypes$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$singleImports$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$$anonfun$typeLinking$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$ConstrSig$$anonfun$apply$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$Env$$anonfun$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$Env$$anonfun$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$Env$$anonfun$4$$anonfun$apply$3: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$Env$$anonfun$5: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$Env$$anonfun$lookupClass$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$Env$$anonfun$Names$Env$$tryName$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$Env$$anonfun$resolveClass$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$FieldCheck$$anonfun$declare$3: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$FieldCheck$$anonfun$declare$4: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$FieldCheck$$anonfun$inherit$2$$anonfun$apply$61: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$FieldCheck$$anonfun$inherit$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$allabs$1$$anonfun$apply$47: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$allabs$1$$anonfun$apply$48: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$allabs$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$declare$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$declare$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$49: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$50: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$inherit$1$$anonfun$apply$51: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$inherit$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$nodecl$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$replace$1$$anonfun$apply$53: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$replace$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$56: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$57: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$58: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$59: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55$$anonfun$apply$60: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54$$anonfun$apply$55: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$replace$2$$anonfun$apply$54: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$replace$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$replaceM$1$$anonfun$apply$52: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodCheck$$anonfun$replaceM$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Names$MethodSig$$anonfun$apply$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Parser$$anon$1$$anonfun$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Parser$$anon$1$$anonfun$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Parser$$anonfun$main$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Parser$$anonfun$parse$1$$anonfun$go$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Parser$$anonfun$parse$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Parser$$anonfun$Parser$$nlines$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Parser$Node$$anonfun$toString$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Scanner$$anonfun$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Scanner$$anonfun$main$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Scanner$$anonfun$maximalmunch$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Scanner$$anonfun$maximalmunch$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> StaticAnal$$anonfun$1$$anonfun$apply$3: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> StaticAnal$$anonfun$1$$anonfun$apply$4: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> StaticAnal$$anonfun$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> StaticAnal$$anonfun$definiteAssignment$1$$anonfun$apply$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> StaticAnal$$anonfun$definiteAssignment$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> StaticAnal$$anonfun$main$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> StaticAnal$$anonfun$reachability$1$$anonfun$apply$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> StaticAnal$$anonfun$reachability$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$3: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$4: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$5: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$6$$anonfun$apply$24: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$6$$anonfun$apply$25: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$6: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$checkAccess$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20$$anonfun$apply$21: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20$$anonfun$apply$22: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$checkConstructorNames$1$1$$anonfun$apply$20: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$checkConstructorNames$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$15: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$17: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$18: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16$$anonfun$apply$19: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1$$anonfun$apply$16: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$checkConstructorSuperInvokes$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$checkForwardReferences$1$1$$anonfun$apply$23: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$checkForwardReferences$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$checkTypes$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disambiguation$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disField$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disField$1$2$$anonfun$apply$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disField$1$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disField$1$3$$anonfun$apply$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disField$1$3: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disField$1$4$$anonfun$apply$3$$anonfun$apply$4: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disField$1$4$$anonfun$apply$3: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disField$1$4: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disField$1$5: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disField$1$6: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disInvoke$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$10: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$11: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$12: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$13: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$14: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disLval$1$1$$anonfun$apply$9: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$disLval$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$formalConf$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$main$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$Types$$disMethod$1$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$Types$$disMethod$1$2$$anonfun$apply$5: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$Types$$disMethod$1$2: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$Types$$disMethod$1$3$$anonfun$apply$6: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$Types$$disMethod$1$3: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$Types$$disMethod$1$4$$anonfun$apply$7$$anonfun$apply$8: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$Types$$disMethod$1$4$$anonfun$apply$7: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$Types$$disMethod$1$4: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$Types$$disMethod$1$5: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Types$$anonfun$Types$$disMethod$1$6: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Util$$anonfun$closure$1: apply(Ljava/lang/Object;)
Util: fix([A]init: A,f: A => A) ===> Util.Memoize: apply(k: Key)