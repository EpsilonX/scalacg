see.values.Vector.Empty: isFlat()
see.values.Vector.Empty: map(mapf: see.values.Val => see.values.Val)
see.values.Vector.Empty: size()
see.values.Vector.Empty: toBool()
see.values.Vector.Empty: toJava()
see.values.Vector.Empty: toLong()
see.values.Vector.Empty: toString()

===========================================================================

see.values.Vector.Empty: <init>() ===> see.values.Vector: <init>(init: Seq[see.values.Val])
see.operations.BoolXor: apply(lhs: see.values.Val,rhs: see.values.Val) ===> see.values.Vector.Empty: toBool()
see.operations.BoolOr: apply(lhs: see.values.Val,rhs: see.values.Val) ===> see.values.Vector.Empty: toBool()
see.operations.Length: apply(s: see.Scope,v: see.values.Val) ===> see.values.Vector.Empty: size()
see.operations.BoolAnd: apply(lhs: see.values.Val,rhs: see.values.Val) ===> see.values.Vector.Empty: toBool()
see.operations.ToBool: apply(s: see.Scope,v: see.values.Val) ===> see.values.Vector.Empty: toBool()
see.values.Vector.$anonfun: apply(i: Int) ===> see.values.Vector.Empty: toJava()
see.operations.Mean: apply(s: see.Scope,v: see.values.Val) ===> see.values.Vector.Empty: size()
see.operations.Zip.$anonfun: apply(x$10: Int,x$11: see.values.Vector) ===> see.values.Vector.Empty: size()
see.values.Container.$anonfun: apply(x$1: see.values.Val) ===> see.values.Vector.Empty: toBool()
see.Binary: apply(lhs: see.values.Val,rhs: see.values.Val) ===> see.values.Vector.Empty: map(mapf: see.values.Val => see.values.Val)
see.operations.Le: apply(lhs: see.values.Val,rhs: see.values.Val) ===> see.values.Vector.Empty: toBool()
see.operations.Ge: apply(lhs: see.values.Val,rhs: see.values.Val) ===> see.values.Vector.Empty: toBool()
see.operations.Rep: apply(s: see.Scope,args: see.values.Val) ===> see.values.Vector.Empty: toLong()
see.Unary: apply(s: see.Scope,v: see.values.Val) ===> see.values.Vector.Empty: map(mapf: see.values.Val => see.values.Val)
see.operations.Pad: apply(s: see.Scope,args: see.values.Val) ===> see.values.Vector.Empty: toLong()
see.operations.ScalProd: apply(lhs: see.values.Val,rhs: see.values.Val) ===> see.values.Vector.Empty: isFlat()
see.values.Container: call(s: see.Scope,args: see.values.Val) ===> see.values.Table: map(mapf: see.values.Val => see.values.Val)
see.values.Container: call(s: see.Scope,args: see.values.Val) ===> see.values.Vector.Empty: map(mapf: see.values.Val => see.values.Val)
see.values.Container: call(s: see.Scope,args: see.values.Val) ===> see.values.Table.Empty: map(mapf: see.values.Val => see.values.Val)
see.values.Container: coerce() ===> see.values.Assoc: map(mapf: see.values.Val => see.values.Val)
see.values.Container: coerce() ===> see.values.Vector.Empty: map(mapf: see.values.Val => see.values.Val)
see.values.Vector: convertTo(destType: Class[_]) ===> see.values.Vector.Empty: toJava()
see.values.Val: convertToObject(destType: Class[_]) ===> see.values.Vector.Empty: toLong()
see.values.Val: convertToObject(destType: Class[_]) ===> see.values.Vector.Empty: toBool()
see.values.Val: convertToPrimitive(destType: Class[_]) ===> see.values.Vector.Empty: toBool()
see.values.Val: convertToPrimitive(destType: Class[_]) ===> see.values.Vector.Empty: toLong()
see.operations.BoolOr: isDefinedFor(s: see.Scope,lhs: see.nodes.Node,rhs: see.nodes.Node) ===> see.values.Vector.Empty: toBool()
see.operations.BoolAnd: isDefinedFor(s: see.Scope,lhs: see.nodes.Node,rhs: see.nodes.Node) ===> see.values.Vector.Empty: toBool()
see.values.Container: isEqualTo(other: see.values.Val) ===> see.values.Vector.Empty: size()
see.operations.Zip: merge(vects: Seq[see.values.Vector]) ===> see.values.Vector.Empty: size()
see.operations.BoolAnd: needsRhs(lhs: see.values.Val) ===> see.values.Vector.Empty: toBool()
see.operations.BoolOr: needsRhs(lhs: see.values.Val) ===> see.values.Vector.Empty: toBool()
see.nodes.Alternative: take(sel: see.values.Val,s: see.Scope) ===> see.values.Vector.Empty: toBool()
see.values.Val: toBig() ===> see.values.BigR: selType()
see.values.Val: toBig() ===> see.values.Lint: selType()
see.values.Val: toBig() ===> see.values.Real: selType()
see.values.Val: toBig() ===> see.values.BigI: selType()
see.values.Val: toDouble() ===> see.values.Lint: selType()
see.values.Val: toDouble() ===> see.values.Real: selType()
see.values.Val: toDouble() ===> see.values.BigR: selType()
see.values.Val: toDouble() ===> see.values.BigI: selType()
see.values.Anonym: toJava() ===> see.values.Vector.Empty: toJava()
see.values.Vector.Empty: toJava() ===> see.values.Vector: jarr()
see.values.Container: toLong() ===> see.values.Table.Empty: size()
see.values.Val: toLong() ===> see.values.BigR: selType()
see.values.Val: toLong() ===> see.values.Vector: selType()
see.values.Val: toLong() ===> see.values.Lint: selType()
see.values.Container: toLong() ===> see.values.Vector.Empty: size()
see.values.Val: toLong() ===> see.values.ValMap: selType()
see.values.Val: toLong() ===> see.values.Assoc: selType()
see.values.Val: toLong() ===> see.values.Table: selType()
see.values.Container: toLong() ===> see.values.ValMap.Empty: size()
see.values.Val: toLong() ===> see.values.Real: selType()
see.values.Val: toLong() ===> see.values.BigI: selType()
see.values.Val: toStr() ===> see.values.Vector.Empty: toString()
see.values.Val: toStr() ===> see.values.SymVal: toString()
see.values.Val: toStr() ===> see.values.Assoc: toString()
see.values.Val: toStr() ===> see.values.Table.Empty: toString()
see.values.Val: toStr() ===> see.values.BigI: toString()
see.values.Val: toStr() ===> see.values.Table: toString()
see.values.Val: toStr() ===> see.values.Str: toString()
see.values.Val: toStr() ===> see.values.ValMap.Empty: toString()
see.values.Scalar: toStr() ===> see.values.Str: toString()
see.values.Scalar: toStr() ===> see.values.Rexp: toString()
see.values.Val: toStr() ===> see.values.ValMap: toString()
see.values.Val: toStr() ===> see.values.Vector: toString()
see.values.Val: toStr() ===> see.values.Rexp: toString()
see.values.Val: toStr() ===> see.values.BigR: toString()
see.values.Val: toStr() ===> see.values.Scalar: toString()
see.values.Scalar: toString() ===> seealues.BigI: v()
see.values.Scalar: toString() ===> seealues.Str: v()
see.values.Scalar: toString() ===> seealues.BigR: v()
see.values.Scalar: toString() ===> seealues.Rexp: v()