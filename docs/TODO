2. super-calls should be ignored if they occur in unreachable methods
   
4. We need to add @invocations annotations to several tests
   - CaseClass1/CaseClass2 -- place some @invocations annotations here?
   - Closures1/Closures2 -- place some @invocations annotations here?

6. I don't understand test AbstractTypes10.  Judging from the assertions,
it seems that method D.hashCode is reachable (perhaps because it
overrides a library method?).  However, if that is the case then why isn't
D.hashCode also a target of the call on line 11?

Note that this test was problematic because main() didn't call any methods.
I added a call to foo() to ensure that the call graph is non trivial, 
but that
led to the inconsistent results I'm observing now.

7. AbstractTypes12 was commented out and lacked assertions. After 
reinstating
the test, and placing assertions on the two method calls, the test 
fails. This
appears to be a bug that has to do with the handling of abstract type 
members.
The problem seemingly has to do with the call on line 21.

1. I reinstated test Generics1 and added a main() method to it. The test currently
  fails for unknown reasons.

3. After adding a missing assertion to Generics4, the test fails. Karim: I think this
is the same problem once again.

5. In test, ImplicitArguments3, it would be nice to put @invocations annotations to check the
presence of constructor calls. Marianna, can you look into that.


1. Test Breakable2 contains method calls that occur in initialization code.
Currently, we cannot express @invocations assertions on calls in such code,
because there is no surrounding method. Therefore, I'd like to allow
@invocations on classes. For now, I added an assertion that forces the 
test to
fail. (note: none of this discussion has anything to do with the "breakable"
construct).

2. If I place an @invocations() annotation without arguments on a method, it
seems to always succeed. This is not the right behavior: it should only 
succeed
if there are no calls within that method.

3. I added some @invocations annotations to tests Match1 and Match2, but
I am not sure if I understand what kinds of calls are generated for 
match-expressions
in general. Marianna: can you check that this makes sense?

4. In test Reachable2/Reachable3, it seems that there is an edge in the 
call graph for a call
  to a library method "scala.collection.mutable.ListBuffer: <init>()".
I edited these tests to force them to fail.

5. test ConstantEquals fails because the @invocations assertion is 
failing. It is not
 clear to me why the asserted call is not in the call graph.

6. Our treatment of calls to methods in the libraries is currently 
inconsistent: we don't
seem to show edges to library methods that are invoked explicitly (e.g. 
calls to println).
On the other hand, we do show calls to methods such as apply() that are 
generated
for match-expressions and the like.  Not sure what to do about 
this--ideally we'd
eventually have all of these edges in our call graphs.

