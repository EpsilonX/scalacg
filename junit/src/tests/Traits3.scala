package tests

import callgraph.annotation.target

/**
 * This example illustrates a situation where analyzing the bytecodes
 * produced by the Scala compiler might result in a loss of precision.
 * Here, we are composing two objects out of traits (X1 with Y1 and 
 * X2 with Y2, respectively), and calling bar(). Each method bar() 
 * calls a method foo(): in the first case, the call is dispatched to 
 * X1.foo() and in the second case, it resolved to X2.foo(), so the 
 * program prints:
 *   X1.foo()
 *   Y1.bar()
 *   X2.foo()
 *   Y2.bar()
 * Intuitively, looking at the Scala source code, this is obvious 
 * because X1 is only ever composed with Y1, and X2 is only ever 
 * composed with Y2.
 * 
 * However, in the generated code for the Y1.foo() method, the call
 * to foo() ends up in a generated class Y1$class, for which the
 * bytecodes look as follows:
 * 
 *   ftipmac2:bin franktip$ javap -c -p p.Y1\$class
 *   Compiled from "Traits3.scala"
 *   public abstract class p.Y1$class extends java.lang.Object{
 *   public static void bar(p.Y1);
 *   Code:
 *   0:		ldc	#9; //String X1.foo
 *   2:		pop
 *   3:		aload_0
 *   4:		invokeinterface	#15,  1; //InterfaceMethod p/Y1.foo:()V
 *   9:		getstatic	#21; //Field scala/Predef$.MODULE$:Lscala/Predef$;
 *   12:	ldc	#23; //String Y1.bar()
 *   14:	invokevirtual	#27; //Method scala/Predef$.println:(Ljava/lang/Object;)V
 *   17:	return
 * 
 * In the compiled code, Y1 and Y2 are subtypes of Y, similar to the situation in
 * the source code.  Furthermore, Y1 has a concrete subtype Traits3$$anon$1 in
 * which the X1.foo() method ended up, and likewise Y2 has a concrete subtype
 * Traits3$$anon$2 in which the X2.foo() method ended up.
 * 
 * Now, performing a Class Hierarchy Analysis on the generated bytecodes
 * would assume that the call could resolve to either Traits3$$anon$1.foo() or 
 * Traits3$$anon$2.foo() because Traits3$$anon$1 and Traits3$$anon$2 are both 
 * subtypes of Y that provide an overriding definition of foo(). As we have 
 * seen above, this is inaccurate. Rapid Type Analysis would do no better, 
 * because the types Test1$$anon$1 and Test1$$anon$2 are both instantiated.
 *  
 * 
 */


object Traits3 {
  def main(args: Array[String]) = {

    { "Y1.bar"; (new X1 with Y1) }.bar();
    { "Y2.bar"; (new X2 with Y2) }.bar();
  }


	trait X1 {
	    @target("X1.foo")  def foo() : Unit = { println("X1.foo()"); }
	}
	
	trait X2 {
	    @target("X2.foo")  def foo() : Unit = { println("X2.foo()"); }
	}
	
	trait Y {
	    def foo(); 
	}
	
	trait Y1 extends Y {
	   @target("Y1.bar") def bar() : Unit = { 
	     { "X1.foo"; this }.foo();  // resolving this call requires understanding how Y1 is composed with other traits
	     println("Y1.bar()"); 
	   }
	}
	
	trait Y2 extends Y {
	    @target("Y2.bar")  def bar() : Unit = { 
	     { "X2.foo"; this }.foo();  // resolving this call requires understanding how Y2 is composed with other traits
	     println("Y2.bar()"); 
	   }
	}

}